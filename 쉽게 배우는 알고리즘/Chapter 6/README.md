# 🌈 Chapter 6: 검색 트리

## 📚 레코드, 키의 정의 및 검색 트리
- 레코드는 개체에 대한 모든 정보를 포함하고 있다. 사람의 레코드라면 주민번호, 이름, 집 주소, 전화번호등 정보가 포함될 수 있다. 이 각각의 정보를 나타내는 부분을 필드라고 한다.
- 검색 트리는 한 노드에서 최대 몇 개의 자식 노드로 분기를 할 수 있느냐에 따라 이진 검색 트리와 다진 검색 트리로 나눈다. 이진 컴색 트리는 최대 두 개의 자식 노드를 가질 수 있고, 다진 검색 트린느 세 개 이상의 자식 노드로 분기할 수 있다.
- 검색 트리는 저장되는 장소에 따라 내부 검색 트리와 외부 검색 트리로 나눈다.
- 검색 트리는 검색키가 포함하는 필드의 수에 따라 일차원 검색 트라와 다차원 검색 트리로 나눈다. 키를 구성하는 필드가 하나이면 일차원 검색 트리, 두 개 이상이면 다차원 검색 트리다.

## 📚 이진 검색 트리
- 이진 검색 트리에는 다음과 같은 특징이 있다.

> 1. 이진 검색 트리의 각 노드는 키 값을 하나씩 갖는다. 각 노드의 키 값은 모두 달라야 한다.
> 2. 최상위 레벨에 루트 노드가 있고, 각 노드는 최대 두 개의 자식 노드를 갖는다.
> 3. 임의의 노드의 키 값은 자신의 왼쪽에 있는 모든 노드의 키 값보다 크고, 오른쪽에 있는 모든 노드의 키 값보다 작다.

### 🎈 이진 검색 트리에서 검색
- 이진 검색 트리에서 키가 x인 노드를 검색하고자 한다. 트리에 키가 x인 노드가 존재하면 해당 노드를 리턴하고, 존재하지 않으면 NIL을 리턴한다.

```
treeSearch(t, x)
// t: 트리의 루트 노드
// x: 검색하고자 하는 키
{
  if (t = NIL or key[t] = x) then return t;
  if (x < key[t])
    then return treeSearch(left[t], x);
    else return treeSearch(right[t], x);
}
```

### 🎈 이진 검색 트리에서 삽입
- 원소 x를 이진 검색 트리에 삽입하려면 우선 이진 검색 트리에 x를 키 값으로 가진 노드가 없어야 한다.
- 원소 x를 삽입할 자리를 찾기 위해서는 우선 실패하는 검색을 한 번 수행해야 한다. 즉, 루트 노드에서 x에 대한 검색을 수행해 임의의 리프 노드에 이르러 더 이상 내려갈 곳이 없음이 확인되면 x를 그 리프 노드의 자식으로 매단다.
- 이진 검색 트리의 모양은 원소들이 삽입되는 순서에 따라 결정된다.

```
treeInsert(t, x)
// t: 트리의 루트 노드
// x: 삽입하고자 하는 키
// 작업 완료 후 루트 노드의 포인터를 리턴한다;
{
  if (t = NIL) then {
    // r: 새 노드
    key[r] <- x;
    left[r] <- NIL;
    right[r] <- NIL;
  }
  if (x < key[t])
    then {
      left[t] <- treeInsert(left[t], x);
      return t;
    }
    else {
      right[t] <- treeInsert(right[t], x);
      return t;
    }
}
```

- n개의 원소로 이진 검색 트리를 만들 때, 이진 검색 트리가 가장 이상적으로 균형이 잡히면 최악의 경우라 하더라도 검색 시간은 ɵ(logn)이다. 가장 나쁘게 기울면 평균 검색 시간이 ɵ(n)이 된다.
- 가능한 모든 삽입 순서에 따른 이진 검색 트리를 모두 고려하면 평균 검색 시간은 ɵ(logn)이다.

### 🎈 이진 검색 트리에서 삭제
- 이진 검색 트리에서 노드 r을 삭제하고자 할 때는 다음 세 가지 경우에 따라 각각 다르게 처리를 해주어야 한다.

> - Case 1: r이 리프 노드인 경우
> - Case 2: r의 자식 노드가 하나인 경우
> - Case 3: r의 자식 노드가 두 개인 경우

- r의 자식 노드가 두 개인 경우에 r 자리에 옮겨놓아도 이진 검색 트리의 성질을 전혀 깨지 않는 원소를 찾는다. 이런 원소는 트리 전체에서 딱 두 개 있다. 바로 r의 왼쪽 서브 트리에서 가장 큰 원소와 r의 오른쪽 서브 트리에서 가장 작은 원소다. 둘 중 하나를 택해 키를 r자리로 옮긴다. 그런 다음 직후 원소가 들어 있던 노드를 삭제한다.

```
treeDelete(t, r, p)
// t: 트리의 루트 노드
// r: 삭제하고자 하는 노드, p: r의 부모 노드
{
  // r이 루트 노드인 경우
  if (r = t) then root <- deleteNode(t);
  // r이 루트 노드가 아닌 경우
  else if (r = left[p])
    then left[p] <- deleteNode(r); // r이 p의 왼쪽 자식
    else right[p] <- deleteNode(r); // r이 p의 오른쪽 자식
}
deleteNode(r)
{
  if (left[r] = right[r] == NIL) then return NIL; // Case 1
  else if (left[r] = NIL and right[r] != NIL) then return right[r]; // Case 2-1
  else if (left[r] != NIL and right[r] = NIL) then return left[r]; // Case 2-2
  else {
    s <- right[r]; // r의 오른쪽 서브 트리
    while(left[s] != NIL) { // s의 왼쪽자식이 존재하지 않을 때까지 (즉, 왼쪽 서브트리에서 가장 작은 값을 찾는다.)
      parent <- s; // s를 부모로 변경
      s <- left[s]; // s는 s의 왼쪽 자식으로 변경
    }
    key[r] <- key[s];
    if (s = right[r]) then right[r] <- right[s]; // r의 오른쪽 서브트리는 s의 오른쪽 서브트리로 변경
                      else left[parent] <- right[s]; // s 부모의 왼쪽값은 s의 오른쪽 서브트리로 변경
    return r;
  }
}
```

- 삭제 작업의 수행 시간은 Case 1과 Case 2는 상수 시간이 든다. Case 3은 노드 r의 직후 원소를 찾는데 최악의 경우 트리의 높이에 비례하는 시간이 든다. 삭제 작업을 위한 최악의 시간은 트리의 높이에 따라 O(logn)과 O(n) 사이에 결정된다.

## 📚 레드 블랙 트리
- 이진 검색 트리는 저장과 검색에 평균 ɵ(logn) 시간이 소요되지만 운이 나쁘면 트리의 모양이 균형을 잘 이루지 못한다. 균형이 많이 깨지면 ɵ(n)에 근접한 시간이 소요될 수도 있다. 그래서 고안해낸 것이 균형잡힌 이진 검색 트리다.
- 균형잡힌 이진 검색 트리로 대표적인 것은 레드 블랙 트리와 AVL 트리다.
- 레드 블랙 트리는 이진 검색 트리의 모든 노드에 레드 또는 블랙의 색상을 칠한다. 단, 다음 성질을 만족하도록 색칠을 칠해야 하는데 이를 레드 블랙 특성이라 한다.

> 1. 루트는 블랙이다.
> 2. 모든 리프(NIL)은 블랙이다.
> 3. 노드가 레드이면 그 노드의 자식은 반드시 블랙이다.
> 4. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.

- 여기서 말하는 리프 노드는 일반적으로 말하는 리프 노드와 의미가 다르다. 이진 검색 트리의 노드가 가진 두 개의 자식 포인터 중 NIL인 것이 있으면 노드를 하나 만들어 그것을 리프 노드라 한다.
- 레드 블랙 트리에서 검색은 트리의 내용을 건들지 않으므로 이진 검색 트리에서 검색과 동일하다.
- 삽입과 삭제도 기본적으로는 이진 검색 트리와 동일하지만 삽입이나 삭제 후 레드 블랙 특성을 위반하는 경우가 발생할 수 있다.

### 🎈 레드 블랙 트리에서 삽입
- 레드 블랙 트리에서 노드를 삽입할 때는 먼저 이진 검색 트리의 삽입 알고리즘에 따라 삽입을 한 다음 **새 노드의 색상을 레드**로 색칠한다. 이 노드를 x라 하고, 새 노드는 항상 맨 아래쪽에 매달리므로 삽입 직후에 x의 아래쪽은 블랙 노드인 리프 2개만 있어 레드 블랙 특성에서 문제가 생기지 않는다. x의 위쪽과 관련해서 문제가 생기는지만 확인하면 된다.
- x의 부모 노드 p가 블랙이면 그것으로 삽입은 완료된다. 그러므로 p가 레드인 경우에만 해결하면 된다.
- p가 레드이면 레드 노드가 2개 연속으로 있으므로 레드 블랙 특성을 위반한다. 그런데 삽입 전에는 레드 블랙 트리였으므로 특성 3에 따라 x의 형제 노드도 반드시 블랙이다. x 주변에서 레드나 블랙 두 가지가 다 가능한 것은 p의 형제 노드 s뿐이다. s의 색상에 따라 다음 두 가지 경우로 나눈다.

> - Case 1: s가 레드
> - Case 2: s가 블랙
>     - Case 2-1: x가 p의 오른쪽 자식
>     - Case 2-2: x가 p의 왼쪽 자식

#### 👉 Case 1
- p와 s의 색상을 레드에서 블랙으로 바꾸고, p<sup>2</sup>의 색상을 블렉에서 레드로 바꾼다. p<sup>2</sup>가 루트이면 p<sup>2</sup> 색상을 다시 블랙으로 바꾸고 끝난다. 
- p<sup>2</sup>가 루트가 아니면 p<sup>2</sup>의 부모 색상을 확인해야 한다. p<sup>2</sup> 부모 색상이 블랙이면 레드 블랙 특성이 모두 만족된다. 
- p<sup>2</sup>의 부모 색상이 레드이면 레드 블랙 특성이 위반되어 처음과 똑같은 문제가 발생한다
- 그렇기 때문에 재귀적으로 문제를 해결한다.

#### 👉 Case 2
- Case 2-1
  - P를 중심으로 왼쪽으로 회전한다. 여전히 레드 블랙 특성을 위반한다. Case 2-2로 이동한다.
- Case 2-2
  - p<sup>2</sup>를 중심으로 오른쪽으로 회전하고 p와 p<sup>2</sup>의 색상을 맞바꾼다.
- Case 2를 만나면 Case 2-2의 수선을 마지막으로 상황이 종료된다. Case 1을 만나면 상황이 끝날 수도 있고 똑같은 상황이 다른 노드에서 다시 시작될 수도 있따. 이런 상황이 재귀적으로 반복되어 루트까지 올라갈 수도 있다.

### 🎈 레드 블랙 트리에서 삭제
- 레드 블랙 트리에서 노드를 삭제할 때는 기본적으로 이진 검색 트리에서 삭제 방법에 따라 노드를 삭제한 후 색상을 맞추어준다.
- 최소 원소 노드 m을 삭제한 후 m 주변의 레드 블랙 특성의 위반 여부가 문제가 발생한다. 최소 원소 노드 m은 왼쪽 자식이 없다. 따라서 **최소 원소 노드 m은 최대 한 개의 자식만을 가질 수 있으므로 두 개의 자식을 가진 노드의 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제 작업으로 귀결된다.**
- 따라서 레드 블랙 트리에서 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제에 귀한해 설명해도 무방하다.
- 삭제하려고 하는 노드 m의 자식을 x라고 한다. **자식이 없으면 x는 NIL 노드가 삭제된다.**
- **m이 레드이면 삭제 후 아무런 조치가 필요 없다** 레드 블랙 특성을 깨지 않는다. 따라서 m이 블랙인 경우만 고려하면 된다.
- **m이 블랙이더라도 x가 레드면 삭제 후 x의 색상을 블랙으로 바꾸어버리면 레드 블랙 특성을 만족한다.** m의 부모 노드 색상은 어떤 색이든 상관없다. 그러므로 까다로운 경우는 m과 x의 색상이 모두 블랙일 때다.
- m과 x가 블랙인 상태에서 m이 삭제되면 x는 m의 부모 p의 자식이 되고 루트에서 x를 통과하는 경로의 블랙 노드 개수가 한 개 모자라서 레드 블랙 특성 4가 깨진다.
