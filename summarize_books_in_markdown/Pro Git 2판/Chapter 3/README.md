# 🌈 Chapter 3: Git의 기초

## 🦄 브랜치란 무엇인가

### 🐣 새 브랜치 생성하기
`git branch` 명령으로 `testing` 브랜치 생성   

```bash
> git branch testing
```

새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.   

지금 작업 중이 브랜치가 무엇인지 Git은 어떻게 파악할까. 다른 버전 관리 시스템과는 달리 Git은 `HEAD`라는 특별한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 `master` 브랜치를 가리키고 있다. `git branch` 명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.

### 🐣 브랜치 이동하기

`git checkout` 명령으로 다른 브랜치로 이동할 수 있다. 한번 `testing` 브랜치로 바꿔보자.

```bash
> git checkout testing
```

이렇게 하면 `HEAD`는 `testing` 브랜치를 가리킨다.   

앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 `testing` 브랜치에서 임시로 작업하고 원래 `master` 브랜치로 돌아와서 하던 일을 계속할 수 있다.

> 브랜치를 이동하면 워킹 디렉터리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉터리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경 시 문제가 있어 브랜치를 이동시키는 게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.


프로젝트 히스토리는 분리돼 진행한다. 우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다. 두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge한다.   

실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을 하나 만드는 것에 불과하다.   
커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge할 떄 어디서부터 합쳐야 하는지 안다.

## 🦄 브랜치와 Merge의 기초

> 1. 작업 중인 웹사이트가 있다.
> 2. 새로운 이슈를 처리할 새 Branch를 하나 생성한다.
> 3. 새로 만드는 Branch에서 작업을 진행한다.

이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다.

> 1. 새로운 이슈를 처리하기 이전의 운영 브랜치로 이동한다.
> 2. Hotfix 브랜치를 새로 하나 생성한다.
> 3. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge한다.
> 4. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.

### 🐣 브랜치의 기초

브랜치를 이동하려면 해야 할 일이 있다. 아직 커밋하지 않은 파일이 Checkout할 브랜치와 충돌 나면 브랜치를 변경할 수 없다. 브랜치를 변경할 때에는 워킹 디렉터리를 정리하는 것이 좋다. 작업하던 것을 모두 커밋하고 `master` 브랜치로 옮긴다.   

Merge할 브랜치가 가리키는 커밋이 현 브랜치 커밋의 Upstream 브랜치이기 때문에 master 브랜치 포인터는 Merge 과정 없이 그저 최신 커밋으로 이동한다. 이런 Merge 방식을 `Fast Forward`라고 부른다. 다시 말해 A 브랜치에서 다른 B 브랜치를 Merge할 때 B 브랜치가 A 브랜치 이후 커밋을 가리키고 있으면 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다.   

더 이상 필요없는 `hotfix` 브랜치는 삭제한다. `git branch` 명령어에 `-d` 옵션을 주고 브랜치를 삭제한다.

```bash
> git branch -d hotfix
```

### 🐣 Merge의 기초

`hotfix`를 Merge했을 때와 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 Merge할 브랜치의 조상이 아니므로 Git은 `Fast-forward`로 Merge하지 않는다. 이 경우에는 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way Merge를 한다.   

단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.   

Git은 Merge하는데 필요한 최적의 공통 조상을 자동으로 찾는다.

### 🐣 충돌의 기초
가끔 3-way Merge가 실패할 때도 있다. Merge하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge하면 Git은 해당 부분을 Merge하지 못한다. 이럴 경우 충돌(Conflict) 메시지를 출력한다.   

Git이 자동으로 Merge하지 못했기에 새 커밋이 생기지 않는다. 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다. Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge할 수 없었는지 살펴보려면 `git status` 명령을 이용한다.   

충돌이 일어난 파일은 `unmerged` 상태로 표시된다. Git은 충돌이 난 부분을 표준 형식에 따라 표시해준다. 그러면 개발자는 해당 부분을 수동으로 해결한다. 이렇게 충돌한 부분을 해결하고 `git add` 명령으로 다시 Git에 저장한다.

## 🦄 브랜치 관리
`git branch` 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다.   

`git branch -v` 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함꼐 보여준다.   

각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션도 있다. 현재 Checkout 한 브랜치를 기준으로 `--merged`와 `--no--merged` 옵션을 사용하며 Merge된 브랜치인지 그렇지 않은 브랜치인지 필터링해 볼 수 있다. `git branch --merged` 명령어로 이미 Merge한 브랜치 목록을 확인한다.

## 🦄 브랜치 워크플로

### 🐣 Long-Running 브랜치
배포했거나 배포할 코드만 `master` 브랜치에 Merge해서 안정 버전의 코드만 `master` 브랜치에 둔다. 개발을 진행하고 안정화하는 브랜치는 develop이나 next라는 이름으로 추가로 만들어 사용한다. 이 브랜치는 언젠가 안정 상태가 되겠지만, 항상 안정 상태를 유지해야 하는 것이 아니다. 테스트를 거쳐서 안정적이라고 판단되면 `master` 브랜치에 Merge한다. 토픽 브랜치에도 적용할 수 있는데, 해당 토픽을 처리하고 테스트해서 버그도 없고 안정적이면 그때 Merge한다.   

사실 우리가 얘기하는 것은 커밋을 가리키는 포인터에 대한 얘기다. 커밋 포인터를 만들고 수정하고 분리하고 합치는지에 대한 것이다. 개발 브랜치는 공격적으로 히스토리를 만들어 나아가고 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다.   

코드를 여러 단계로 나누어 안정성을 높여가며 운영할 수 있다. 프로젝트 규모가 크면 proposed 혹은 pu(proposed updates)라는 이름의 브랜치를 만들고 next나 mater 브랜치에서 아직 Merge할 준비가 되지 않은 것을 일단 Merge시킨다. 중요한 개념은 브랜치를 이용해 여러 단계에 걸쳐서 안정화해 나아가면서 충분히 안정화가 됐을 때 안정 브랜치로 Merge한다는 점이다. 다시 말해서 Long-Running의 브랜치가 여러 개일 필요은 없지만 정말 유용하 할 수 있다

### 🐣 토픽 브랜치
토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치다. 보통 주제별로 브랜치를 만들고, 각각은 독립돼 있기 때문에 매우 쉽게 컨텍스트 사이를 옮겨 다닐 수 있다. 묶음 별로 나눠서 일하면 내용별로 검토하기에도, 테스트하기에도 더 편한다. 각 작업을 하루든 한 달이든 유지하다가 master 브랜치에 Merge할 시점이 되면 순서와 관계없이 그 때 Merge하면 된다.   

## 🦄 리모트 브랜치
리모트 Refs는 리모트 저장소에 있는 포인터인 레퍼런스다. 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다. `git ls-remote (remote)` 명령으로 모든 리모트 Refs를 조회할 수 있다. `git remote show (remote)` 명령은 모든 리모트 브랜치와 그 정보를 보여준다. 리모트 Refs가 있지만 보통 리모트 트래킹 브랜치를 사용한다.   

리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 브랜치다. 이 브랜치는 로컬에 있지만 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트 브랜치에 따라서 자동으로 움직일 뿐이다.   

리모트 브랜치의 이름은 (remote)/(branch) 형식으로 되어 있다. (ex. origin/master) origin으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/mater라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 origin/mater를 가리키게 한다. 이제 master 브랜치에서 작업을 시작할 수 있다.   

리모트 서버로부터 저장소 정보를 동기화하려면 `git fetch origin` 명령을 사용한다. 명령을 실행하면 우선 origin 서버의 주소 정보를 찾아서, 현재 로컬의 저장소가 갖고 있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.

### 🐣 Push하기
로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 리모트 저장소에 Push해야 한다. 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않는다. 명시적으로 브랜치를 Push해야 정보가 전송된다. 따라서 리모트 저장소에 전송하지 않고 로컬 브랜치에만 두는 비공개 브랜치를 만들 수 있다. 또 다른 사람과 협업하기 위해 토픽 브랜치만 전송할 수도 있다.

```bash
> git push (remote) (branch) 
```

Fetch 명령으로 리모트 트래킹 브랜치를 내려 받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 새로 생기는 것이 아니다. 다시 말해서 브랜치가 생기는 것이 아니라 그저 수정 못하는 origin 브랜치 포인터가 생기는 것이다.

### 🐣 브랜치 추적
리모트 트래킹 브랜치를 로컬 브랜치로 Checkout하면 자동으로 트래킹 브랜치가 만들어진다. 트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다. 트래킹 브랜치에서 `git pull` 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge한다.   

서버로부터 저장소를 Clone을 하면 Git은 자동으로 master 브랜치를 origin/master 브랜치의 트래킹 브랜치로 만든다. 트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master가 아닌 다른 브랜치로 추적할 수 있다.   

리모트 브랜치와 다른 이름으로 브랜치를 만들려면 로컬 브랜치의 이름을 아래와 같이 다르게 지정한다.

```bash
> git checkout -b sf origin/serverfix
```

이제 `sf` 브랜치에서 Push나 Pull하면 자동으로 origin/serverfix로 데이터를 보내거나 가져온다.   

추적 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 `git branch` 명령에 `-vv` 옵션을 더한다. 이 명령을 실행하면 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다. 게다가 로컬 브랜치가 앞서가는지 뒤처지는지에 대한 내용도 보여준다.

```bash
> git branch -vv
```

### 🐣 Pull하기
`git fetch` 명령을 실행하면 서버에는 존재하지만, 로컬에는 아직 없는 데이터를 받아와서 저장한다. 이때 워킹 디렉터리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 Merge하도록 준비만 해둔다.   

간단히 말하면 `git pull` 명령은 대부분 `git fetch`명령을 실행하고 나서 자동으로 `git merge` 명령을 수행하는 것뿐이다.   

일반적으로 `fetch`와 `merge` 명령을 명시적으로 사용하는 것이 `pull` 명령으로 한 번에 두 작업을 하는 것보다 낫다.

### 🐣 리모트 브랜치 삭제
`git push` 명령에 `--delete` 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다. `serverfix`라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.

```bash
> git push origin --delete serverfix
```

위 명령을 실행하면 서버에서 브랜치 하나가 사라진다. 서버에서 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 살릴 수 있다.
