# 🤔 Chapter 2: 실용주의 접근법

## 🍭 Topic 8. 좋은 설계의 핵심

> **Tip 14. 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.**

어떤 게 잘 설계되었다는 건 그 물건이 사용하는 사람에게 적응하여 맞춰진다는 것이다. 이 말을 코드에 적용해 보면, 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰저야 한다. 그래서 우리는 ETC 원칙을 따른다. 바꾸기 **더 쉽게**(Easier to Change, ETC). 이게 전부다.   

우리가 아는 한 세상의 모든 설계 원칙은 ETC의 특수한 경우다.   

왜 결합도를 줄이면 좋은가? 관심사를 분리함으로써 각각이 더 바꾸기 쉬워지기 떄문이다. ETC.   
왜 단일 책임 원칙이 유용한가? 요구 사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문이다. ETC.   
왜 이름 짓기가 중요한가? 이름이 좋으면 코드가 읽기 쉬워지고, 코드를 바꾸려면 코드를 읽어야 하기 때문이다. ETC!   

### 🥕 ETC는 규칙이 아니라 가치
가치는 여러분이 결정을 내리게 도움을 주는 것이다. 소프트웨어라는 틀에서 생각해 보면 ETC는 선택의 갈림길에서 도움을 주는 안내자다.   

ETC에는 암묵적인 전제가 있다. 바로 여러 길 중 어떤 길이 미래의 변경을 쉽게 만드는지 알 수 있다는 것이다. 상식이 대개 통할 테고, 여러분의 지식을 바탕으로 추측할 수 있을 것이다. 하지만 가끔은 아무 실마리가 없을 수도 있다. 그래도 괜찮다. 이런 경우 다음 두 가지를 해 보라.   

첫 번째로, 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제건 궁극의 "바꾸기 쉽게"라는 길을 선택한다. 바로 여러분이 작성하는 코드를 교체하기 쉽게 만들도록 노력하는 것이다. 교체 가능하게 작성하라는 말은 코드의 결합도를 낮추고 응집도를 높이라는 이야기일 뿐이다.   

두 번째는 이런 경우를 여러분의 직관을 발전시키는 기회로 삼으라는 것이다.

## 🍭 Topic 9. DRY: 중복의 해악
지식은 변화한다. 떄로는 급격하게 변화한다. 프로그래머는 늘 유지 보수 모드에 있다. 우리의 이해는 날마다 바뀐다. 우리가 프로젝트에 열중해 있는 동안에도 새로운 요구 사항이 도착하고 기존 요구 사항은 진화한다.   

소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 우리가 DRY라 부르는 원칙을 따르는 것이라 생각한다. DRY 원칙은 다음과 같다.   
**모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.**

> **Tip 15. DRY: 반복하지 말라(Don't Repeat Yourself)**

DRY를 따르지 않으면 똑같은 것이 두 군데 이상에 표현될 것이다. 하나를 바꾸면 나머지도 바꿔야 함을 기억해야 한다. 우리는 DRY가 "실용주의 프로그래머"의 도구 상자에서 가장 중요한 도구 중 하나라고 생각한다.

### 🥕 DRY는 코드 밖에서도
많은 사람들이 DRY가 코드에만 해당한다고 받아들였따. "소스 코드를 복사-붙여넣기 하지 말라."로 이해한 것이다.   

그것도 DRY의 일부인 것은 **맞다.** 하지만 아주 작고 자명한 부분일 뿐이다. DRY는 **지식의 중복**, **의도의 중복**에 대한 것이다. 똑같은 개념을 다른 곳 두 군데에서 표현하면 안 된다는 것이다. 경우에 따라서 중복 표현이 두 가지 완전히 다른 방식으로 이루어질 수도 있다.

### 🥕 모든 코드 중복이 지식의 중복은 아니다

```ruby
def validate_age(value):
    validate_type(value, :integer)
    validate_min_integer(value, 1)

def validate_quantity(value):
    validate_type(value, :integer)
    validate_min_integer(value, 1)
```

코드는 동일하지만 두 함수가 표현하는 지식은 다르다. 두 함수는 각각 서로 다른 것을 검증하고 있지만, 우연히 규칙이 같은 것뿐이다. 이것은 우연이지 중복이 아니다.

### 🥕 문서화 중복
왜인지는 모르겠지만 모든 함수에 주석을 달아야 한다는 미신이 생겨났다. 한 번은 주석으로, 또 한 번은 코드로 함수의 의도는 두 번 표현된다.   
우리는 수정사항이 생기면 두 군데를 함꼐 고쳐야 한다. 시간이 지남에 따라 주석과 코드의 내용이 서로 어긋나게 될 거라고 거의 확실히 장담할 수 있다.   

우리가 보기에는 이름이나 코드 구조의 부실함을 메꾸는 역할을 할 뿐이다. 함수 이름이 함수가 하는 일을 알려준다. 더 자세한 것을 알고 싶다면 소스 코드를 보면 된다. 이것이 DRY다!

### 🥕 표현상의 중복
여러분의 코드는 바깥세상과 연결된다. 다른 라이브러리와는 API로, 다른 서비스와는 원결 호출이나 외부 저장소의 데이터 등으로 연결된다. 그리고 이렇게 연결될 때마다 일종의 DRY 위반을 하게 된다. 외부에 무언가에 표현된 지식인 API나 스키마, 에러 코드의 의미 등을 여러분의 코드도 알아야만 하는 것이다.  여기서는 연결을 표현하는 지식을 여러분의 코드와 외부의 존재 양쪽이 모두 알아야 하기 때문에 중복이 생긴다. 한쪽에서만 바꾸면 다른 쪽은 망가질 것이다.   

이런 중복은 아예 피할 수는 없지만 다소 완화할 수는 있다.

#### 내부 API에서 생기는 중복
언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구를 찾아보라. 이런 도구는 일반적으로 문서와 목 API, 기능 테스트를 생성해 주고, API 클라이언트도 여러 가지 언어로 생성해 준다. 이상적으로는 이 도구를 이용하여 모든 API 정의를 중앙 저장소에 넣어 두고 여러 팀이 공우할 수 있게 하면 좋다.

#### 외부 API에서 생기는 중복
공개 API를 OpenAPI 같은 형식으로 엄밀하게 문서화하는 경우가 점점 많아지고 있다. 이런 형식의 API 명세를 여러분의 API 도구로 불러와서 사용하면 더욱 신뢰성 있게 해당 서비스를 연동할 수 있다.

#### 데이터 저장소와의 중복
많은 데이터 저장소가 데이터 스키마 분석 기능을 제공한다. 이런 기능을 이용하면 데이터 저장소와 코드 간의 중복을 많이 제거할 수 있다.

### 🥕 개발자 간의 중복
아마 발견하거나 없애기 가장 어려운 유형의 중복은 같은 프로젝트에서 일하는 개발자들 사이에서 발생할 것이다. 똑같은 일을 하는 코드가 우연히 중복으로 추가될 수 있고, 이런 중복은 수년 동안 발견되지 않을 수 있다.   
개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다. 우리가 느끼기에 최선책은 개발자 간의 적극적이고 빈번한 소통을 장려하는 것이다.   
일일 스크럼 스탠드업 미팅을 운영해 볼 수 있다. 슬랙 채널같이 공통의 문제를 다루기 위한 공간을 만들라. 이런 소프트웨어를 사용하면 모든 대화 기록을 보존할 수 있고, 방해를 최소화하면서 의사소통이 가능하다.   

팀원 한 사람을 프로젝트 사서로 임명하라. 프로젝트 사서의 역할은 지식 교환을 돕는 것이다. 그리고 일상적으로든 코드 리뷰를 통해서든 다른 사람의 소스 코드와 문서를 반드시 읽어라. 다른 사람의 것을 기웃거리는 게 아니고, 거기서 배우는 것이다. 그리고 기억하라. 접근은 상호적이다. 다른 사람이 **여러분**의 코드를 들여다보고 건드린다고 해서 기분 나빠하지 말 일이다.

> **Tip 14. 재사용하기 쉽게 만들어라.**

여러분은 뭔가를 직접 만드는 것보다 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성해야 한다. **사람들은 쉽지 않으면 하지 않을 것이다.** 그리고 재사용에 실패한다면 지식 중복의 위험을 감수해야 한다.

## 🍭 Topic 10. 직교성
직교성(orthogonality)은 설게와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념이다.

### 🥕 직교성이란
컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다. 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스와 서로 직교할 것이다.

### 🥕 직교성의 장점
비직교적인 시스템은 본질적으로 변경과 조정이 더 복잡하다. 시스템의 컴포넌트들이 고도로 상호 의존적인 경우 특정 부분만 국지적으로 수정하는 방법이란 없다.

> **Tip 17. 관련 없는 것들 간에 서로 영향이 없도록 하라.**

우리가 설계하고 싶은 것은 자족적인 컴포넌트, 즉 단일하고 잘 정의된 목적을 가진 독립적인 컴포넌트다. 컴포넌트들이 각기 격리되어 있으면 어느 하나 바꿀 때 나머지 것들을 걱정하지 않아도 된다. 해당 컴포넌트의 외부 인터페이스를 바꾸지 않는 한 전체 시스템으로 퍼져 나가는 문제를 일으키지는 않으리라고 확신할 수 있다.   

직교적인 시스템을 작성하면 두 가지 큰 장점이 있다. 바로 생산성 향상과 리스크 감소다.

#### 생상성 향상
- 변화를 국소화해서 개발 시간과 테스트 시간이 줄어든다. 상대적으로 작고, 자족적인 컴포넌트들을 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다. 간단한 컴포넌트는 설계하고, 코딩하고, 테스트하고, 그러고는 잊어버릴 수 있다. 새로운 코드를 추가할 때마다 기존의 코드를 계속 바꾸지 않아도 된다.
- 직교적인 접근법은 재사용도 촉진된다. 컴포넌트에 명확하고 잘 정의된 책임이 할당되어 있으면 애초의 구현자가 예상하지 못한 방식으로 새로운 컴포넌트와 결합할 수 있다. 시스템이 더 느슨하게 결합되어 있을수록 재조합하고 개량하기 쉽다.
- 직교적인 컴포넌트들을 결합하는 경우 얻을 수 있는 꽤 미묘한 생산성 향상 요소가 있다. 컴포넌트 하나가 M가지 서로 다른 일을 하고 또 다른 컴포넌트 하나가 N가지 일을 한다고 가정하자. 만약 두 컴포너트가 직교적이라면 결합했을 때 결과물을 M x N가지 일을 한다.

#### 리스크 감소
직교적인 접근법은 모든 개발 작업에 존재할 수밖에 없는 위험의 크기를 감소시켜 준다.
- 감염된 코드가 격리되어 있다.
- 시스템이 잘 깨지지 않는다. 어떤 부분을 골라서 약간 바꾸고 고쳤을 때 혹시 문제가 생기더라도 문제점은 그 부분으로 한정될 것이다.
- 직교적인 시스템은 그 안의 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽기 떄문에, 아무래도 테스트를 더 많이 하게 된다.
- 특정 업체나 제품, 플랫폼에 덜 종속될 것이다.

### 🥕 설계
시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 되어 유연성이 높아진다. 계층 구조는 또한 모듈 간에 의존성이 폭증할 위험을 줄인다.   

설계가 직교적인지 확인하는 손쉬운 방법이 있다. 컴포넌트들을 나누었을 때 다음과 같이 스스로에게 물어보라. "특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가?" 직교적인 시스템에서는 답이 "하나"여야 한다.    

여러분이 제어할 수 없고, 언제 어떤 이유로든 바뀔 수 있다. **자신의 힘으로 제어할 수 없는 속성에 의존하지 말라.**

### 🥕 툴킷과 라이브러리
외부에서 만든 툴킷이나 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴보기 바란다. 기술을 현명하게 선택하라.   

툴킷이나 라이브러리를 도입할 때는 심지어 같은 팀의 다른 멤버가 작성한 것이더라도 이것이 여러분의 코드에 수용해서는 안 될 변화를 강요하지 않는지 검토해 보라.

### 🥕 코딩
코드를 작성할 때마다 여러분은 애플리케이션의 직교성을 떨어트릴 위험을 감수하는 셈이다. 현재 코딩하는 부분뿐만 아니라 애플리케이션의 큰 맥락을 끊임없이 살피지 않으면 의도치 않게 다른 모듈에 있는 기능을 또 추가하거나 동일한 지식을 두 번 표현할 수 있다.   

직교성을 유지하기 위해 사용할 수 있는 몇 가지 기법이 있다.

#### 코드의 결합도를 줄여라
부끄럼쟁이(shy) 코드를 작성하라. 즉, 불필요한 것은 다른 모듈에 보여 주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라. 그리고 데메테르 법칙을 따르려 노력해 보자. 객체의 상태를 바꿀 필요가 있다면 여러분을 위해 객체가 직접 상태를 바꾸게 하라. 이렇게 한다면 코드는 다른 코드 구현으로부터 분리된 채로 남아있을 것이며, 계속하여 직교성을 유지할 확률이 높아진다.

#### 전역 데이터를 피하라
코드가 전역 데이터를 참조할 때마다 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다.

#### 유사한 함수를 피하라
종종 유사해 보이는 함수를 여럿 구현해야 할 떄가 있다. 아마도 시작과 끝에서는 동일한 코드를 사용하지만, 중간의 알고리즘이 다를 것이다. 중복 코드는 구조에 문제가 있다는 징후다.   


자신이 작성하느 코드를 항상 비판적으로 바라보는 습관을 길러라. 기회가 있을 때마다 코드의 구조와 직교성을 개선하기 위해 노력하라. 이런 과정을 리팩터링이라 부른다.

### 🥕 테스트
직교적으로 설계하고 구현한 시스템은 테스트하기 더 쉽다. 시스템 컴포넌트 간의 상호 작용이 형식을 잘 갖추고 있고 제한적이기 때문에 시스템 테스트 중 많은 부분을 개별 모듈 수준에서 수행할 수 있다. 모듈 수준의 테스트나 단위 테스트가 통합 테스트보다 테스트 케이스를 만들고 수행하기 훨씬 쉬우므로 이는 좋은 소식이라 할 수 있다.   

단위 테스트를 작성하는 행위 자체가 직교성을 테스트해 볼 수 있는 기회다. 단위 테스트를 빌드하고 실행하기 위해 어떤 작업이 필요한가? 나머지 시스템 중 상당 부분을 불러와야 하지는 않는가? 만약 그렇다면 모듈과 나머지 시스템 사이의 결합도를 충분히 줄이지 못했다는 뜻이다.   

만약 버전 관리 시스템을 사용한다면, 테스트를 마친 뒤 코드를 병합할 때 버그 수정에 대한 태그를 붙여라. 이렇게 하면 버그 수정마다 수정한 소스 파일 개수를 수집하여 그 경향을 분석한 월 단위 리포트를 만들 수 있을 것이다.

### 🥕 문서화
놀랍게도 직교성은 문서에도 적용할 수 있다. 내용과 표현이라는 두 개의 축이 있다. 정말 직교적인 문서라면 내용 변화 없이 모양새를 완전히 바꿀 수 있을 것이다. 워드 프로세서가 제공하는 스타일 시트와 매크로를 사용하면 쉽게 할 수 있다. 우리는 개인적으로 마크다운 같은 마크업 체계를 좋아한다. 내용을 쓸 때는 내용에만 집중하고, 예쁘게 꾸미는 것 같은 다른 변환 도구에 맡길 수 있다.

### 🥕 직교적으로 살아가기
직교성은 DRY 원칙과도 밀접한 관계가 있다. DRY 원칙은 시스템 내부의 중복을 최소화하고, 직교성은 시스템 컴포넌트 간의 상호 의존도를 줄인다. DRY 원칙으로 무장하고 직교성 원칙을 충실히 적용한다면 개발하고 있는 시스템이 더 유연하고 이해하기 쉬워질 것이다. 디버깅, 테스트, 유지 보수 또한 쉬워질 것이다.
