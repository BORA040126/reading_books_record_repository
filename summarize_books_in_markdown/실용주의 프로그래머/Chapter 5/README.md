# 🤔 구부러지거나 부러지거나

현대의 미친 듯이 빠른 변화 속도를 따라가려면 모든 수단을 동원하여 가능한 한 느슨하고 유연한 코드를 작성해야 한다.

## 🍭 Topic 28. 결합도 줄이기
결합도가 높으면 이리저리 연결되어 있어서 여러 가지를 동시에 바꿔야 한다. 그래서 바꾸기 더 어려워진다. 여러분의 운명은 둘 중 하나다. 바꿔야 하는 곳을 모두 찾아내느라 시간을 들이거나, 아니면 "딱 하나만" 바꾸고 결합된 다른 것들은 잊은 채 왜 프로그램이 죽는지 고민하느라 시간을 들이거나.   

소프트웨어 구조는 유연해야 한다. 그리고 유연하려면 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.

> **Tip 44. 결합도가 낮은 코드가 바꾸기 쉽다.**

### 🥕 열차 사고

```java
public void applyDiscount(customer, order_id, discount) {
  totals = customer
    .orders
    .find(order_id)
    getTotals();

  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```

이 코드는 합계까지 다섯 단계의 추상화를 오간다. 결국 최상위 코드가 모든 것을 알아야 한다. 코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다. 설상가상으로 이 코드를 계속 지원하기 위해서 **앞으로 바꾸면 안 되는 것**도 너무 많다.

> **Tip 45. 묻지 말고 말하라(Tell, Don't Ask)**

이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 개체를 갱신해서는 안 된다는 것이다. 객체의 내부 상태를 묻는 것으로 인하여 캡슐화의 장점은 완전히 사라지고, 또 그 과정에서 구현에 대한 지식이 코드 여기저기로 퍼져 버린다. 따라서 우리 열차 사고를 고치는 첫 발짝은 할인 처리를 `totals` 객체에 위임하는 것이다.

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .orders
    .find(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```

주문 컬렉션을 가져와서 주문을 찾아서는 안 된다. 고객 객체에서 바로 주문 객체를 얻어 와야 한다.

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```

마찬가지 논리를 주문 객체와 합계에도 적용할 수 있다. 주문 객체를 구현할 때 합계를 별도의 객체에 저장했다는 사실은 왜 온 세상 사람들이 알아야 하겠는가?

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .applyDiscount(discount);
}
```

#### 데메테르 법칙(디미터 법칙, Law of Demeter)

> **Tip 46. 메서스 호출을 역지 말라.**

무언가에 접근할 때 "."을 딱 하나만 쓰려고 노력해 보라. "무언가에 접근"한다는 건 중간 변수를 사용하는 경우까지 포함해야 한다.

```ruby
# 좋지 않은 방식이다.
amount = customer.orders.last().totals().amount;

# 마찬가지로 좋지 않다.
orders = customer.orders;
last = orders.last();
totals = last.totals();
amount = totals.amount;
```

점 하나 규칙에는 큰 예외가 하나 있다. 엮는 것들이 절대로 바뀌지 않을 것 같다면 이 규칙을 지키지 않아도 된다. 언어에 기본으로 포함된 라이브러리는 아마 꽤 안정적일 것이고, 다음과 같이 써도 될 것이다.

```ruby
people
  .sort_by { |person| person.age }
  .first(10)
  .map {| person | person.name }
```

#### 연쇄와 파이프라인
파이프라인은 함수에서 함수로 데이터를 넘겨 가며 데이터를 변환한다. 이런 파이프라인은 메서드 호출로 이루어진 열차 사고와는 다르다. 숨겨진 구현 세부 사항에 의존하지 않기 때문이다.   

그렇다고 파이프라인이 결합을 하나도 만들지 않는 것은 아니다. 파이프라인의 함수에서 반환하는 데이터는 반드시 다음 함수가 처리할 수 있는 형식이어야 한다.   

### 🥕 글로벌화의 해악
어디서나 접근할 수 있는 데이터는 교묘하게 애플리케이션 컴포넌트 간의 결합을 만들어 낸다. 전역 데이터 하나하나는 애플리케이션의 모든 메서드에 갑자기 매개 변수가 추가된 것과 같은 효과를 낸다. 전역 데이터는 **모든** 메서드 안에서 사용할 수 있으니 말이다.   

전역 데이터는 여러 가지 방법으로 코드의 결합도를 높인다. 전역 데이터의 구현을 변경할 때 시스템 코드 전체에 영향을 줄 수 있음은 분명하다.   

전역 데이터는 코드를 떼어 내는 경우에도 문제를 만든다. 코드를 재사용할 수 있도록 해야 한다는 생각이 코딩 습관이 일부가 되어야 한다. 코드를 재사용할 수 있도록 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다. 그래야 나머지 것들이 우르르 딸려 들어오는 일 없이 메서드나 모듈을 뽑아낼 수 있다.   

전역 데이터를 쓰는 코드에 단위 테스트를 만들다 보면 이런 문제를 발견하게 된다. 그저 테스트를 실행하려는 것뿐인데 전역 환경을 생성하는 코드를 한참이나 써야 한다.

#### 싱글턴(singleton)도 전역 데이터다
앞에서 우리는 일부러 **전역 변수**가 아니라 **전역 데이터**라고 계쏙 말했다. 가끔씩 "이것 보세요. 전역 변수는 없어요. 모두 인스턴스 데이터로 싱글턴이나 전역 모듈 안에 넣었어요."라고 말하는 사람이 있기 때문이다.   

여러분의 코드에 있는 것이 싱글턴뿐이더라도, 외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터다. 그저 이름이 좀 길어졌을 뿐이다.   

#### 외부 리소스도 전역 데이터다
수정 가능한 외부 리소스는 모두 전역 데이터다. 여러분의 애플리케이션이 데이터베이스나 저장소, 파일 시스템, 서비스 API 등을 사용한다면 전역 데이터의 함정에 빠질 위험이 있는 것이다. 여기서도 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다.

> **Tip 48. 전역적이어야 할 만큼 중요하다면 API로 감싸라.**

### 🥕 상속은 결합을 늘린다
상속으로 다른 클래스의 상태와 행동을 그대로 가져올 수 있다. 상속을 잘못 사용하는 문제는 너무 중요해서 별도로 항목을 만들었다. (항목 31. 상속세 참고)

### 🥕 결국은 모두 ETC
결합된 코드는 바꾸기 힘들다. 코드의 한 곳을 바꾸면 다른 곳에 여파가 미칠 수 있다. 가끔은 찾기 힘든 곳에 문제가 생기는 바람에 한 달 후에나 서비스에 오류가 발생하면서 문제의 실상이 드러나기도 한다.   

직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라. 그러면 애플리케이션의 결합도를 낮게 유지할 수 있을 것이고, 결과적으로 코드를 바꾸기 쉬워질 것이다.
