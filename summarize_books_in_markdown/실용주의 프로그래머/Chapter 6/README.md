# 🤔 동시성

동시성은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다. 그리고 병렬성이란 실제로 동시에 실행되는 것이다.   
동시성을 얻으려면 실행 중에 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야 한다. 보통은 파이버(fiber)나 스레드, 프로세스 등을 사용하여 동시성을 구현한다.   
병렬성을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요하다.

### 🥕 모든 일에 동시성이 있다
시스템의 규모가 어느 정도를 넘어가면 동시성을 고려하지 않고 코드를 작성하기란 거의 불가능하다. 동시성을 겉으로 드러날 때도 있지만 라이브러리 안에 묻혀 있는 경우도 있다. 여러분의 애플리케이션이 실제 세상을 다루기 원한다면 동시성은 필수다. 세상은 비동기적이기 때문이다. 만약 순차적으로 하나를 끝낸 다음에 다음 일을 하는 식으로 수행한다면, 시스템은 거북이처럼 느리게 느껴질 것이고 프로그램을 구동하는 하드웨어의 성능도 최대로 활용하지 못할 것이다.   

## 🍭 Topic 33. 시간적 결합 깨트리기
소프트웨어 아키텍처에서 시간이라는 측면은 자주 무시된다. 우리가 신경쓰는 유일한 시간은 일정, 바로 출시까지 남은 시간뿐이다. 하지만 여기서 이야기할 것은 이런 종류의 시간이 아니다. 시간에는 우리가 신경 써야 할 측면이 두 가지 있는데, 동시성(동시에 일어나는 일들)과 순서(시간의 흐름 속에서 일들의 상대적인 위치)다.   

우리는 보통 프로그래밍할 때 두 측면 모두 특별히 신겨 쓰지 않는다. 메서드 A는 언제나 메서드 B보다 먼저 호출해야 한다. 보고서는 한 번에 오직 하나만 생성할 수 있다. 버튼 클릭을 처리하려면 먼저 화면이 갱신되어야 한다.   

이러한 접근 방법은 그다지 유연하지 않고 현실과도 동떨어져 있다.   
우리는 동시성을 확보해야 한다. 시간이나 순서에 의존하는 시간적 결합을 끊는 방법을 생각해 내야 한다. 그렇게 함으로써 유연성도 얻을 수 있고, 작업 흐름 분석과 아키텍처, 설계, 배포와 같은 개발의 여러 측면에서 시간과 관련된 의존성도 함께 줄일 수 있다. 결과적으로 분석하기 더 쉽고 응답속도도 더 빠르며 더 안정적인 시스템을 만들 수 있을 것이다.

### 🥕 동시성 찾기
우리는 동시에 **일어나도 되는** 게 뭐고, 반드시 순서대로 **일어나야 하는** 건 어떤 것인지 찾아내길 원한다. "활동 다이어그램" 같은 표기법을 사용해서 작업 흐름을 그록하는 것이 한 방법이다.

> **TIP 56. 작업 흐름 분석으로 동시성을 개선하라.**

활동 다이어그램을 사용하면 동시에 **수행할 수도 있는데도** 아직 동시에 하고 있지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다.

### 🥕 동시 작업의 기회
활동 다이어그램은 동시에 작업할 수 있는 부분들을 보여 준다. 하지만 진짜로 동시에 하는 것이 좋은지는 알려주지 않는다. 그래서 설계가 필요하다.   
우리는 시간이 걸리지만, 우리 코드가 아닌 곳에서 시간이 걸리는 활동을 찾고 싶다. 데이터베이스를 조회할 때나 외부 서비스에 접근할 때, 사용자 입력을 기다릴 때 같이 우리 프로그램이 다른 작업이 끝나기를 기다려야 하는 상황 말이다. 이런 순간이 바로 CPU가 손가락만 빨면서 기다리는 대신 좀 더 생산적인 일을 할 수 있는 기회다.

### 🥕 병렬 작업의 기회
컴퓨터 한 대에 있든 아니면 연결된 여러 대에 있든 우리에게 여러 개의 프로세서가 있다면, 그리고 작업을 프로세서들에게 나누어 줄 수 있다면 전체 소요 시간을 단축할 수 있다.   
이런 식으로 나누기에 가장 이상적인 것은 비교적 독립적인 부분 작업들이다. 다른 부분 작업을 기다릴 필요 없이 진행할 수 있으면 좋다. 일반적인 형태는 커다란 작업을 독립적인 부분들로 쪼개서 별렬로 각각 처리한 다음, 결과를 합치는 것이다.   

### 🥕 기회를 찾아 내는 것은 쉽다
여러분의 애플리케이션으로 돌아가자. 동시 작업이나 병렬 작업을 해서 이득을 볼 수 있는 부분을 찾았다. 이제 어려운 부분이 남았다. 어떻게 안전하게 구현할 수 있을까?

## 🍭 Topic 34. 공유 상태는 틀린 상태

여러분이 가장 좋아하는 레스토랑에 방문했다. 메인 요리를 모두 먹은 후 종업원에게 혹시 애플파이가 남아 있는지 묻는다. 종업원은 어꺠 넘어를 돌아보더니 진영장에 한 조각이 남아 있는 것을 확인하고는 그렇다고 대답한다. 여러분은 주문을 마치고 안도의 한숨을 내쉰다.   
한편 레스토랑의 반대쪽에서도 다른 고객이 종업원에게 같은 질문을 하고 있다. 이 종업원도 진열장을 쳐다보고는 한 조각이 있는 것을 확인하고 주문을 받는다. 두 고객 중 한 명은 실망하게 될 것이다.

> **Tip 57. 공유 상태는 틀린 상태다.**

문제는 상태가 공유된 것이다. 레스토랑의 종업원들은 서로를 고려하지 않고 진열장만 확인했다.

### 🥕 비-원자적 갱신

종업원1이 현재 파이 조각 수를 조회하고, 1을 얻는다. 그러고는 고객에게 파이를 약속한다. 하지만 이 시점에 종업원2도 작업을 시작한다. 역시 파이 조각 수를 조회하여 1을 얻고, 고객에게 똑같은 약속을 한다. 둘 중 하나가 마지막 남은 파이 조각을 획득하고, 다른 종업원은 일종의 예외 상태에 빠진다.   

여기서 문제는 두 프로세스가 같은 메모리 영역을 쓰기가 가능하다는 점이 아니다. 문제는 어느 프로세스도 자신이 보는 메모리가 일관되어 있음을 보장할 수 없다는 점이다. 이것은 모두 파이 조각을 가져오고 갱신하는 동안이 원자적이지 않기 떄문이다. 실제 값이 그사이에 바뀔 수 있다. 그렇다면 어떻게 원자적으로 바꿀 수 있을까?

#### 세마포어 및 다른 상호 배제 방법
세마포어는 단순히 한 번에 한 사람만이 가질 수 있는 **무언가**다. 여러분은 세마포어를 만들어서 다른 리소스의 사용을 제어하는 데 쓸 수 있다.   

레스토랑에서는 물리적인 세마포어로 파이 문제를 해결하기로 했다. 진열장 위에 도깨비 인형을 하나 올려 둔다. 모든 종업원은 파이 주문을 받기 전에 도깨비 인형을 손에 넣어야 한다. 주문을 받고 파이를 접시에 담아 고객에게 낸 후에는 도깨비 인형을 보물 파이를 지키는 원래 위치에 되돌려 놓는다. 다음 주문을 받을 수 있도록 말이다.

```ruby
case_semaphore.lock()

if display_case.pie_count > 0
  promise_pie_to_customer()
  display_case.take_pie()
  give_pie_to_customer()
end

case_semaphore.unlock()
```

두 종업원이 동시에 코드를 실행시켰다고 가정해 보자. 둘 다 세마포어를 얻으려고(lock) 시도하지만 한 명만 성공한다. 세마포어를 확보한 쪽은 평소처럼 계속 진행한다. 세마포어를 얻지 못한 쪽은 세마포어를 얻을 수 있을 때까지 멈춰 있는다. 즉, 기다린다. 첫 번째 종업원이 주문을 완료하고 세마포어의 잠금을 해제하면 다른 종업원이 실행을 재개한다.   

이 접근 방식에는 몇 가지 문제가 있다. 가장 큰 문제는 진영장에 접근하는 모든 사람이 빠짐없이 세마포어를 사용해야만 제대로 동작한다는 것이다. 만약 누군가가 깜빡한다면, 다시 말해서 어떤 개발자가 약속을 지키지 않는 코드를 쓴다면 다시 혼돈에 빠진다.

#### 리소스를 트랜잭션으로 관리하라
현재의 설계가 미흡한 것은 진열장 사용을 보호할 책임을 진열장을 사용하는 사람에게 전가하기 때문이다. 제어를 중앙으로 집중시키자. 그러려면 API를 바꿔서 종업원이 하나의 호출로 파이 조각 수를 확인함과 동시에 파이 조각을 가져가도록 만들어야 한다.   

```ruby
def get_pie_if_available()
  @case_semaphore.protect() {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
end
```

### 🥕 트랜잭션이 없는 갱신
공유 메모리는 동시성 문제의 원인으로 많이 지목받는다. 하지만 사실 수정 가능한 리소스를 공유하는 애플리케이션 코드 **어디에서나** 동시성 문제가 발생할 수 있다. 여러분 코드의 인스턴스 둘 이상이 파일, 데이터베이스, 외부 서비스 등 어떤 리소스에 동시에 접근할 수 있다면 여러분은 잠재적인 문제를 안고 있는 것이다.   

> **Tip 58. 불규칙한 실패는 동시성 문제인 경우가 많다.**

### 🥕 그 밖의 독점적인 접근
대부분의 언어에는 공유 리소스에 독접적으로 접근하는 것을 도와주는 라이브러리가 있다. 상호 배제를 의미하는 뮤텍스라고 부르기도 하고, 모니터나 세마포어라고 부르기도 한다. 모두 라이브러리로 제공된다.   

언어 자체에 동시성 지원이 들어 있는 언어도 있다. 예를 들어 러스트는 데이터의 소유권이라는 개념을 강제한다. 변경 가능한 데이터 조각은 어느 한 시점에 단 하나의 변수나 매개 변수만 참조를 가질 수 있다.   

함수형 언어들은 모든 데이터를 변경 불가능하게 만드는 경향이 있으므로 동시성 문제를 단순하게 만든다고 주장할 수도 있겠다. 하지만 함수형 언어도 언젠가는 모든 것이 변경 가능한 진짜 세상에 발을 들여야 하므로 똑같은 문제를 겪는 순간이 올 것이다.

### 🥕 의사 선생님, 아파요.....
혹시 이번 항목에서 얻어 가는 것이 없다면 이것만은 기억하기를 바란다. 리소스를 공유하는 환경에서 동시성은 어렵다. 이문제를 직접 풀려고 한다면 고난의 연속일 것이다.   

그래서 다음 오래된 농담을 음미해보기를 추천하는 것이다.

> 의사 선생님, 이렇게 하면 아파요.   
> 그러면 그렇게 하지 마세요.
