---
sidebar_position: 6
---

# 🤔 Chapter 5: 구부러지거나 부러지거나

현대의 미친 듯이 빠른 변화 속도를 따라가려면 모든 수단을 동원하여 가능한 한 느슨하고 유연한 코드를 작성해야 한다.

## 🍭 Topic 28. 결합도 줄이기
결합도가 높으면 이리저리 연결되어 있어서 여러 가지를 동시에 바꿔야 한다. 그래서 바꾸기 더 어려워진다. 여러분의 운명은 둘 중 하나다. 바꿔야 하는 곳을 모두 찾아내느라 시간을 들이거나, 아니면 "딱 하나만" 바꾸고 결합된 다른 것들은 잊은 채 왜 프로그램이 죽는지 고민하느라 시간을 들이거나.   

소프트웨어 구조는 유연해야 한다. 그리고 유연하려면 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.

> **Tip 44. 결합도가 낮은 코드가 바꾸기 쉽다.**

### 🥕 열차 사고

```java
public void applyDiscount(customer, order_id, discount) {
  totals = customer
    .orders
    .find(order_id)
    getTotals();

  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```

이 코드는 합계까지 다섯 단계의 추상화를 오간다. 결국 최상위 코드가 모든 것을 알아야 한다. 코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다. 설상가상으로 이 코드를 계속 지원하기 위해서 **앞으로 바꾸면 안 되는 것**도 너무 많다.

> **Tip 45. 묻지 말고 말하라(Tell, Don't Ask)**

이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 개체를 갱신해서는 안 된다는 것이다. 객체의 내부 상태를 묻는 것으로 인하여 캡슐화의 장점은 완전히 사라지고, 또 그 과정에서 구현에 대한 지식이 코드 여기저기로 퍼져 버린다. 따라서 우리 열차 사고를 고치는 첫 발짝은 할인 처리를 `totals` 객체에 위임하는 것이다.

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .orders
    .find(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```

주문 컬렉션을 가져와서 주문을 찾아서는 안 된다. 고객 객체에서 바로 주문 객체를 얻어 와야 한다.

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .getTotals()
    .applyDiscount(discount);
}
```

마찬가지 논리를 주문 객체와 합계에도 적용할 수 있다. 주문 객체를 구현할 때 합계를 별도의 객체에 저장했다는 사실은 왜 온 세상 사람들이 알아야 하겠는가?

```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .applyDiscount(discount);
}
```

#### 데메테르 법칙(디미터 법칙, Law of Demeter)

> **Tip 46. 메서스 호출을 역지 말라.**

무언가에 접근할 때 "."을 딱 하나만 쓰려고 노력해 보라. "무언가에 접근"한다는 건 중간 변수를 사용하는 경우까지 포함해야 한다.

```ruby
# 좋지 않은 방식이다.
amount = customer.orders.last().totals().amount;

# 마찬가지로 좋지 않다.
orders = customer.orders;
last = orders.last();
totals = last.totals();
amount = totals.amount;
```

점 하나 규칙에는 큰 예외가 하나 있다. 엮는 것들이 절대로 바뀌지 않을 것 같다면 이 규칙을 지키지 않아도 된다. 언어에 기본으로 포함된 라이브러리는 아마 꽤 안정적일 것이고, 다음과 같이 써도 될 것이다.

```ruby
people
  .sort_by { |person| person.age }
  .first(10)
  .map {| person | person.name }
```

#### 연쇄와 파이프라인
파이프라인은 함수에서 함수로 데이터를 넘겨 가며 데이터를 변환한다. 이런 파이프라인은 메서드 호출로 이루어진 열차 사고와는 다르다. 숨겨진 구현 세부 사항에 의존하지 않기 때문이다.   

그렇다고 파이프라인이 결합을 하나도 만들지 않는 것은 아니다. 파이프라인의 함수에서 반환하는 데이터는 반드시 다음 함수가 처리할 수 있는 형식이어야 한다.   

### 🥕 글로벌화의 해악
어디서나 접근할 수 있는 데이터는 교묘하게 애플리케이션 컴포넌트 간의 결합을 만들어 낸다. 전역 데이터 하나하나는 애플리케이션의 모든 메서드에 갑자기 매개 변수가 추가된 것과 같은 효과를 낸다. 전역 데이터는 **모든** 메서드 안에서 사용할 수 있으니 말이다.   

전역 데이터는 여러 가지 방법으로 코드의 결합도를 높인다. 전역 데이터의 구현을 변경할 때 시스템 코드 전체에 영향을 줄 수 있음은 분명하다.   

전역 데이터는 코드를 떼어 내는 경우에도 문제를 만든다. 코드를 재사용할 수 있도록 해야 한다는 생각이 코딩 습관이 일부가 되어야 한다. 코드를 재사용할 수 있도록 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다. 그래야 나머지 것들이 우르르 딸려 들어오는 일 없이 메서드나 모듈을 뽑아낼 수 있다.   

전역 데이터를 쓰는 코드에 단위 테스트를 만들다 보면 이런 문제를 발견하게 된다. 그저 테스트를 실행하려는 것뿐인데 전역 환경을 생성하는 코드를 한참이나 써야 한다.

#### 싱글턴(singleton)도 전역 데이터다
앞에서 우리는 일부러 **전역 변수**가 아니라 **전역 데이터**라고 계쏙 말했다. 가끔씩 "이것 보세요. 전역 변수는 없어요. 모두 인스턴스 데이터로 싱글턴이나 전역 모듈 안에 넣었어요."라고 말하는 사람이 있기 때문이다.   

여러분의 코드에 있는 것이 싱글턴뿐이더라도, 외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터다. 그저 이름이 좀 길어졌을 뿐이다.   

#### 외부 리소스도 전역 데이터다
수정 가능한 외부 리소스는 모두 전역 데이터다. 여러분의 애플리케이션이 데이터베이스나 저장소, 파일 시스템, 서비스 API 등을 사용한다면 전역 데이터의 함정에 빠질 위험이 있는 것이다. 여기서도 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다.

> **Tip 48. 전역적이어야 할 만큼 중요하다면 API로 감싸라.**

### 🥕 상속은 결합을 늘린다
상속으로 다른 클래스의 상태와 행동을 그대로 가져올 수 있다. 상속을 잘못 사용하는 문제는 너무 중요해서 별도로 항목을 만들었다. (항목 31. 상속세 참고)

### 🥕 결국은 모두 ETC
결합된 코드는 바꾸기 힘들다. 코드의 한 곳을 바꾸면 다른 곳에 여파가 미칠 수 있다. 가끔은 찾기 힘든 곳에 문제가 생기는 바람에 한 달 후에나 서비스에 오류가 발생하면서 문제의 실상이 드러나기도 한다.   

직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라. 그러면 애플리케이션의 결합도를 낮게 유지할 수 있을 것이고, 결과적으로 코드를 바꾸기 쉬워질 것이다.

## 🍭 Topic 29. 실세계를 갖고 저글링하기

### 🥕 이벤트
이벤트는 무언가 정보가 있다는 것을 의미한다. 정보는 사용자가 버튼을 클릭하거나, 주가 정보가 갱신될 때처럼 외부에서 올 수 있다.

### 🥕 유한 상태 기계

#### 실용주의 FSM 해부학
기본적으로 상태 기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다. 정해진 상태들이 있고 그중 하나가 "현재 상태"다. 상태마다 그 상태일 때 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 "현재 상태"를 정의한다.   

FSM의 멋진 점은 FSM을 오로지 데이터만으로 표현할 수 있다는 것이다.

#### 행동 추가하기
특정한 상태 이행이 일어날 떄 수행하는 행동을 추가하여 FSM을 더 강력하게 만들 수 있다.   

#### 상태 기계는 시작일 뿐
상태 기계는 개발자들에게 저평가되어 있다. 여러분이 상태 기계를 적용할 수 있는 곳을 한번 찾아보면 좋겠다. 하지만 상태 기계가 이벤트와 관련된 모든 문제를 해결하지는 못한다.

### 🥕 감시자 패턴
감시자 패턴은 이벤트를 발생시키는 쪽인 감시 대상과 이런 이벤트에 관심이 있는 클라이언트인 감시자로 이루어진다.   
감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다. 보통은 호출될 함수의 참조도 등록할 때 함께 넘긴다. 나중에 해당 이벤트가 발생하면 감시 대상은 등록된 감시자 목록을 보면서 함수들을 일일이 호출한다. 이때, 발생한 이벤트를 감시자 함수의 인자로 넘긴다.   

감시 대상을 만드는 코드는 별게 없다. 함수 참조를 리스트에 추가하고, 이벤트가 일어나면 이 함수들을 호출한다.   

"감시자-감시 대상" 패턴은 수십 년간 쓰여 왔고, 잘 작동했다. 특히 사용자 인터페이스 시스템에서 널리 쓰이는데, 어떤 상호 작용이 일어났다는 것을 애플리케이션에 콜백으로 알려주는 방식을 사용한다.   

하지만 감시자 패턴에는 문제가 하나 있다. 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 결합이 생긴다. 더군다나 일반적으로 감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 이 부분이 성능 병목이 될 수 있다.   
동기적 처리의 특성상 콜백 실행이 끝날 때까지 감시 대상이 계속 기다려야 하기 때문이다. 이 문제는 다음 전략인 "게시-구독"으로 해결한다.

### 🥕 게시-구독
게시-구독 혹은 발행-구독 모델은 줄여서 펍섭이라고도 부르며 감시자 패턴을 일반화한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.   

게시-구독 모델에는 게시자와 구독자가 있고, 이들은 채널로 연결된다. 채널은 별도 코드로 구현되는데, 이런 상세한 구현 내용은 여러분의 코드로부터 숨겨져 있다.   

각 채널에는 이름이 있다. 구독자는 관심사를 하나 이상의 채널에 등록하고, 게시자는 채널에 이벤트를 보낸다. 감시자 패턴과는 다르게 게시자와 구독자 사이의 통신은 여러분의 코드 밖에서 일어난다. 아마 비동기적으로 이루어질 것이다.   

게시-구독 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋은 기술이다. 대신 단점은 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기가 힘들다는 것이다. 게시자가 메시지를 보내는 것을 확인했더라도 어떤 구독자가 그 메시지를 처리하는지 바로 이어서 볼 수 없다.   

### 🥕 반응형 프로그래밍과 스트림 그리고 이벤트
어떤 셀에 들어 있는 수식에서 다른 셀을 참조하고 있을 때, 참조된 셀의 값을 바꾸면 첫 번째 셀의 값도 바뀐다. 값이 바뀌면 그 값을 사용하는 다른 값이 "반응하는" 것이다.   
이런 데이터 수준의 반응성을 구현할 수 있는 프레임워크가 많이 있다. 브라우저 세계에서는 현재 리액트와 뷰의 인기가 가장 높다.   

이벤트를 사용하여 코드가 반응하도록 할 수 있다는 것은 명백하다. 하지만 이벤트를 이리저리 연결하는 것도 쉽지많은 않다. 그래서 스트림이 필요하다.   

스트림은 이벤트를 일반적인 자료 구조처럼 다룰 수 있게 해 준다. 이벤트의 리스트를 다룬다고 생각하면 된다. 새로운 이벤트가 도착하면 이 리스트가 길어지는 셈이다. 이런 방식이 좋은 이유는 익숙한 방식으로 스트림을 다룰 수 있기 때문이다. 이벤트를 처리하고, 조합하고, 골라내는 등 우리가 아는 온갖 작업을 일반적인 자료 구조와 마찬가지 방법으로 할 수 있다. 심지어 이벤트 스트림과 일반 자료 구조를 조합할 수도 있다. 또한 스트림은 비동기적으로 작동할 수도 있는데, 이벤트가 도착했을 때 여러분의 코드가 이벤트에 응답할 기회를 얻는다.   

첫 번째 예제는 두 개의 스트림을 받아서 하나로 엮는다. 그러면 결과로 새로운 스트림이 생기는데, 첫 번재 스트림에서 원소 하나, 두 번째 스트림에서 원소 하나를 가져와서 하나로 묶은 것이 새로운 스트림의 원소가 된다. 다음 예에서 첫 번째 스트림은 그냥 동물 이름 다섯 개다. 두 번째 스트림은 좀 더 흥미로운데, 500ms마다 이벤트를 발생시키는 반복 타이머다. 두 스트림이 집으로 엮였기 때문에 둘 모두에 데이터가 있을 때만 엮인 스트림에 결과가 생긴다. 즉, 출력 스트림은 0.5초에 한 번씩 결과를 내보낸다.

```js
import * as Observable from 'rxjs';
import { logValues } from '../rxcommon/logger.js';

let animals = Observable.of("ant", "bee", "cat", "dog", "elk");
let ticker = Observable.interval(500)

let combined = Observable.zip(animals, ticker);

combined.subscribe(next => logValues(JSON.stringify(next)));
```

위 코드는 브라우저 창의 목록에 새로운 항목을 추가하는 간단한 로깅 함수를 사용한다. 각 항목에는 프로그램이 시작된 후부터 흐른 시간을 밀리초 단위로 붙인다. 500ms마다 하나씩 스트림에서 이벤트를 받고 있다. 브라우저에서 실행해 보면 로그 항목이 정확하게 0.5초마다 나타난다.   

### 🥕 어디에나 이벤트가 있다
이벤트는 모든 곳에 있다. 몇 가지는 뻔하다. 마우스 버튼을 클릭하거나 타이머가 울린다. 하지만 그렇게 뻔하지 않은 경우도 있다. 누군가가 로그인하거나 파일의 특정 줄이 패턴과 일치한다. 하지만 이벤특 어디서 발생하든 이벤트를 중심으로 공들여 만든 코드는 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.   

## 🍭 Topic 30. 변환 프로그래밍
모든 프로그램은 데이터를 변환한다. 받은 입력은 출력으로 바꾼다. 하지만 우리는 설계를 고민할 때 변환을 만드는 것에 대해서는 거의 생각하지 않는다. 오직 클래스와 모듈, 자료 구조, 알고리즘, 언어, 프레임워크에 대해서만 걱정할 뿐이다.   

우리는 이렇게 코드에만 집중하면 핵심을 놓칠 수 있다고 본다. 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다. 이렇게 생각하면 그동안 고민하던 많은 세부 사항이 모두 사라진다. 구조는 명확해지고 더 일관적으로 오류를 처리하게 되어 결합도 대폭 줄어들 것이다.   

> **Tip 49. 프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다.**

### 🥕 변환 찾기
때에 따라선 요구 사항에서 시작하는 게 변환을 찾는 가장 쉬운 방법이다. 요구 사항에서 입력과 출력이 무엇인지 찾으면 전체 프로그램을 나타내는 함수가 정해진다. 이제 입력을 출력으로 바꿔 가는 단계들을 찾으면 된다. 일종의 하향식 접근 방식이다.   

### 🥕 이것이 왜 그리 대단한가?

```scala
word
|> all_subset_longer_than_three_characters()
|> sa_unique_signatures()
|> find_in_dictionary()
|> group_by_length()
```

요구 사항을 달성하기 위해 필요한 것은 하나로 연결된 변환들뿐이다. 각각은 앞의 변환에서 입력을 받아 처리한 결과를 다음 변환으로 넘겨준다. 이보다 글처럼 읽기 쉬운 코드는 만들기 어려울 것이다.   

하지만 더 깊은 의미도 있다. 객체 지향 프로그래밍 경혐이 많다면 반사적으로 데이터를 숨기고, 객체 안에 캡슐화해야 한다고 느낄 것이다. 이런 객체들은 서로 이리저리 이야기하며 서로의 상태를 변경한다. 이런 방식은 결합을 많이 만들어 내고, 이는 결국 객체 지향 시스템이 바꾸기 어려워지는 큰 요인이 된다.

> **Tip 50. 상태를 쌓아 놓지 말고 전달하라.**

변환 모델에서는 이런 사고를 근본적으로 뒤엎는다. 데이터를 전체 시스템 여기저기의 작은 웅덩이에 흩어 놓는 대신, 데이터를 거대한 강으로, 흐름으로 생각하라. 데이터는 기능과 동등해진다. 파이프라인은 코드 -> 데이터 -> 코드 -> 데이터 ...의 연속이다. 데이터는 더 이상 클래스를 정의할 때처럼 특정한 함수들과 묶이지 않는다. 대신 우리 애플리케이션이 입력을 출력으로 바꾸어 나가는 진행 상황을 데이터로 자유롭게 표현할 수 있다. 이 말인즉슨 결합을 대폭 줄일 수 있다는 것이다. 어떤 함수든 매개 변수가 다른 함수의 출력 결과와 맞기만 하면 어디서나 사용하고 또 재사용할 수 있다.

### 🥕 오류 처리는 어떻게 하나.
여러 가지 방법이 있지만 공통으로 사용하는 기본적인 관례가 하나 있다. 바로 변환 사이에 값을 절대 날것으로 넘기지 않는 것이다. 대신 래퍼 역할을 하는 자료 구조나 타입으로 값을 싸서 넘긴다. 이런 자료 구조나 타입은 안에 들어 있는 값이 유효한지를 추가로 알려 준다. 예를 들어 하스켈에서 이런 래퍼를 `Maybe`라고 부르고, F#과 스칼라에서는 `Option`이다.   

이런 개념을 어떻게 활용하는지는 언어에 따라 다르다. 하지만 코드 작성 방식은 기본적으로 크게 두 가지로 나뉜다. 오류 검사를 변환 안에서 하는 방식과 변환 바깥에서 하는 방식이다.

### 🥕 변환은 프로그래밍을 변환한다
코드를 일련의 (중첩된) 변환으로 생각하는 접근 방식은 프로그래밍을 해방시킨다. 익숙해지는 데는 시간이 좀 걸리지만, 일단 습관을 들이면 여러분의 코드가 더 명확해지고, 함수는 짧아지며, 설계는 단순해질 것이다.
