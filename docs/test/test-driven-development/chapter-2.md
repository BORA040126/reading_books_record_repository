---
sidebar_position: 3
sidebar_label: 1. 타락한 객체
---

# 🌈 Chapter 2: 타락한 객체

일반적인 TDD 주기는 다음과 같다.

1. 테스트를 작성한다. 마음속에 있는 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는지 생각해보라. 이야기를 써내려가는 것이다. 원하는 인터페이스를 개발하라. 올바른 답을 얻기 위해 필요한 이야기의 모든 요소를 포함시켜라.
2. 실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다. 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하라. 만약 깔끔하고 단순한 해법이 있지만 구현하는 데 몇 분 정도 걸릴 것 같으면 일단 적어 놓은 뒤에 원래 문제로 돌아오자.
3. 올바르게 만든다. 이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자. 좁고 올곧은 소프트웨어 정의의 길로 되돌아와서 중복을 제거하고 초록 막대로 되돌리자.

우리 목적은 작동하는 깔끔한 코드를 얻는 것이다. 작동하는 깔끔한 코드를 얻는 것은 때로는 최고의 프로그래머들 조차 도달하기 힘든 목표고, 나같은 대부분의 평범한 프로그래머들에게는 거의 불가능한 일이다. 그렇다면 나누어서 정복하자. 일단 "작동하는 깔끔한 코드"를 얻어야 한다는 전체 문제 중에서 "작동하는"에 해당하는 부분을 먼저 해결하라. 그러고 나서 "깔끔한 코드" 부분을 해결하는 것이다. 이러한 접근 방식은 "깔끔한 코드" 부분을 먼저 해결한 후에, "작동하는" 부분을 해결해 가면서 배운 것들을 설계에 반영하느라 허둥거리는 아키텍처 주도 개발과 정반대다.

나는 다음과 같이 쓸 수 있길 바란다.

```java
public void testMultiplication() {
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(10, product.amount);
  five.times(3);
  assertEquals(15, product.amount);
}
```

`Dollar`의 인터페이스를 수정해야 하고, 그러기 위해서는 테스트도 수정해야 한다.

```java
public void testMultiplication() {
  Dollar five = new Dollar(5);
  Dollar product = five.times(2);
  assertEquals(10, product.amount);
  product = five.times(3);
  assertEquals(15, product.amount);
}
```

`Dollar.times()`를 아래와 같이 수정하기 전엔 새 테스트는 컴파일조차 되지 않을 것이다.

```java
Dollar times(int multiplier) {
  amount *= multiplier;
  return null;
}
```

이제 테스트가 컴파일된다. 하지만 실행되지는 않는다. 그래도 한 걸음 나아간 것이다! 테스트를 통과하기 위해서는 올바른 금액을 갖는 새 `Dollar`를 반환해야 한다.

```java
Dollar times(int multiplier) {
  return new Dollar(amount * multiplier);
}
```

다음은 최대한 빨리 초록색을 보기 위해 취할 수 있는 내가 아는 세 전략 중 두 가지다.

- 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
- 명백한 구현 사용하기: 실제 구현을 입력한다.

나는 보통 실무에서 TDD를 사용할 때 두 방법을 번갈아가며 사용한다. 모든 일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 계속 더해 나간다. 예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다. 그러다 다시 자신감을 되찾으면 명백한 구현 사용하기 모드로 돌아온다.
