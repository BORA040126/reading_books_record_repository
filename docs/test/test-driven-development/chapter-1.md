---
sidebar_position: 2
sidebar_label: 1. 다중 통화를 지원하는 Money 객체
---

# 🌈 Chapter 1: 다중 통화를 지원하는 Money 객체

> P.41 참고

다중 통화를 지원하는 보고서를 만들려면 통화 단위를 추가해야 한다. 또한 환율도 명시해야 한다.   

새로운 보고서를 생성하려면 어떤 기능들이 있어야 할까? 즉 어떤 테스트들이 있어야 보고서에 제대로 계산되도록 하는 코드가 완성됐다는 걸 확신할 수 있을까?   
- 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

우선 어떤 테스트가 필요할까? 할일 목록을 보니 첫 번째 테스트는 좀 복잡해 보인다. 작은 것부터 시작하든지, 아니면 아예 손을 대지 않는 게 좋다. 이번엔 다음 항목인 곱하기를 보자. 대단히 어렵진 않겠지? 이걸 먼저 하는 게 좋겠다.   
테스트를 작성할 때는 오퍼레이션의 완벽한 인터페이스에 대해 상상해보는 것이 좋다.

```java
public void testMultiplication() {
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(10, five.amount);
}
```

방금 우리가 작성한 테스트는 아직 컴파일조차 되지 않는다. 현재 네 개의 컴파일 에러가 있다.
- `Dollar` 클래스가 없음
- 생성자가 없음
- `times`(`int`) 메서드가 없음
- `amount` 필드가 없음

한 번에 하나씩 정복하기로 하자. `Dollar` 클래스를 정의하면 에러 하나는 없앨 수 있다.

```java
class Dollar
```

에러가 하나 없어졌으니 이제 세 개 남았다. 이제 생성자를 만들어보자. 그냥 컴파일만 되게 할 거니까 생성자 안에서는 아무 일도 안 해도 된다.

```java
Dollar(int amount) {
  // ...
}
```

이제 `times()` 의 스텁 구현이 필요하다. 이번에도 역시 컴파일만 될 수 있게 해주는 최소한의 구현만 할 것이다.

```java
void times(int multiplier) {
  // ...
}
```

이제 하나 남았다. 마지막으로 `amount` 필드를 추가하자.

```java
int amount;
```

이제 테스트를 실행해서 테스트가 실패하는 모습을 볼 수 있게 됐다. 우리가 만든 코드 조각을 실행한 후 그 결과로 `10`이 나와야 하는데 `0`이 나왔다는 것을 알려준다. 막연히 실패했다는 사실만 아는 것보다 나아진 것이다.   

내가 상상할 수 있는 최소 작업은 다음과 같다.

```java
int amount = 10;
```

테스트를 실행해보면 초록 막대를 보게 된다. 하지만 주기가 아직 완성되지 않았다.   
주기는 다음과 같다. 잊지 말 것.

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

주기의 1번부터 4번 항목까지를 수행했다. 이제 중복을 제거할 차례다. 그런데 어디가 중복이란 말인가? 보통 여러분은 중복을 찾기 위해 코드를 비교할 것이다. 하지만 이번 경우엔 중복이 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다. 못 찾겠는가? 코드를 다음과 같이 썼다면 어땠을까?

```java
int amount = 5 * 2;
```

여기에서 10은 다른 어딘가에서 넘어온 값이다. 사실 우린 우리가 인식조차 할 수 없을 만큼 빨리 머릿속으로 곱셈을 수행한 것이다. 이제 5와 2가 두 곳에 존재한다. 따라서 우린 무자비하게 이 중복ㅇㄹ 제거해야 한다. 규칙이 그러니까.   
5와 2를 한 번에 제거할 수 있는 방법은 없다. 하지만 객체를 초기화 단계에 있는 설정 코드를 `times()` 메서드 안으로 옮겨보면 어떨까?

```java
int amount;

void times(int multiplier) {
  amount = 5 * 2;
}
```

테스트는 여전히 통과하고 테스트 막대 역시 초록색이다.   

이 단계가 너무 작게 느껴지는가? 하지만 기억하기 바란다. **TDD의 핵심은 이런 작은 단계를 밟아야 한다는 것이 아니라, 이런 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.** 내가 일상에서 항상 이런 식으로 작업하는지 궁금한가? 그렇지 않다. 하지만 일이 좀 묘하게 꼬이기 시작하면 난 작은 단계를 밟을 능력이 내게 있다는 사실을 기뻐하게 된다. 만약 정말 작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 될 것이다. 그러나 큰 단계로만 작업했다면, 더 작은 단계가 적절한 경우에 대해 결코 알지 못하게 된다.   

생성자에서 넘어오는 값이니 이걸 다음과 같이 `amount` 변수에 저장하면,

```java
Dollar(int amount) {
  this.amount = amount;
}
```

그걸 `times()` 에서 사용할 수 있다.

```java
void times(int multiplier) {
  amount = amount * 2;
}
```

인자 `multiplier`의 값이 2이므로, 상수를 이 인자로 대체할 수 있다.

```java
void times(int multiplier) {
  amount = amount * multiplier;
}
```

연산자를 변경해줄 수 있다.

```java
void times(int multiplier) {
  amount *= multiplier;
}
```

이제 첫 번째 테스트에 완료 표시를 할 수 있게 됐다.   

지금까지 한 작업을 검토해보자. 우리는 다음 작업들을 해냈다.
- 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다.
- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
- JUnit에 대한 상세한 사항들은 잠시 무시하기로 했다.
- 스텁 구현을 통해 테스트를 컴파일했다.
- 끔찍한 죄악을 범하여 테스트를 통과시켰다.
- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.
- 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.
