---
sidebar_position: 3
sidebar_label: 2. 타입스크립트의 타입 시스템
---

# 🐤 Chapter 1: 타입스크립트의 타입 시스템

## 🥕 아이템 6. 편집기를 상뇽하여 타입 시스템 탐색하기
- 편집기에서 타입스크립트 언어 서비스를 적극 활용해야 합니다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있습니다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 합니다.

## 🥕 아이템 7. 타입이 값들의 집합이라고 생각하기
런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가집니다. 변수에는 다음처럼 다양한 종류의 값을 할당할 수 있습니다.
- `42`
- `null`
- `undefined`
- `'Canada'`
- `{ animal: 'Whale', weight_lbs: 40_000 }`
- `/regex/`
- `new HTMLButtonElement`
- `(x, y) => x + y`

그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 "타입"을 가지고 있습니다. "할당 가능한 값들의 집합"이 타입이라고 생각하면 됩니다. 이 집합은 타입의 "범위"라고 부르기도 합니다.   

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 타입스크립트에서는 `never` 타입입니다. `never` 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 없습니다.   

그 다음으로 작은 집합은 한 가지 값만 포함하는 타입입니다. 이들은 타입스크립트에서 유닛(unit) 타입이라고도 불리는 리터럴 타입입니다.

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온 타입을 사용합니다. 유니온 타입은 값 집합들의 합집합을 일컫습니다.

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

타입이 집합이라는 관점에서 `extends`의 의미는 *~에 할당 가능한*과 비슷하게, *~의 부분 집합*이라는 의미로 받아들일 수 있습니다.

```ts
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
```

`Vector3D`는 `Vector2D`의 서브타입이고 `Vector2D`는 `Vector1D`의 서브타입입니다.   
`extends` 키워드는 제너릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 "~의 부분 집합"을 의미하기도 합니다.

```ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```

`string`의 부분 집합 법위를 가지는 어떠한 타입이 됩니다. 이 타입은 `string` 리터럴 타입, `string` 리터럴 타입의 유니온, `string` 자신을 포함합니다.

```ts
getKey({}, 'x'); // 정상, string을 상속
getKey({}, Math.random() < 0.5 ? 'a' : 'b'); // 정상, string을 상속
getKey({}, document.title); // 정상
getKey({}, 12); // ~~~ '12' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
```

타입이 값의 집합이라는 건, 동일한 값의 집합을 가지는 두 타입은 같다는 의미가 됩니다. 두 타입이 의미적으로 다르고 우연히 같은 범위를 가진다고 하더라도, 같은 타입을 두 번 정의할 이유는 없습니다.

## 🥕 아이템 8. 타입 공간과 값 공간의 심벌 구분하기
타입스크립트 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재합니다. 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있습니다.

```ts
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

`interface Cylinder`에서 `Cylinder`는 타입으로 쓰입니다. `const Cylinder`에서 `Cylinder`와 이름은 같지만 값으로 쓰이며, 서로 아무런 관련도 없습니다. 상황에 따라서 `Cylinder`는 타입으로 쓰일 수도 있고, 값으로 쓰일 수도 있습니다. 이런 점은 가끔 오류를 야기합니다.   

한 심벌이 타입인지 값인지는 언뜻 봐서 알 수 없습니다. 어떤 형태로 쓰이는지 문맥을 살펴 알아내야 합니다. 많은 타입 코드가 값 코드와 비슷해 보이기 때문에 더더욱 혼란스럽습니다.   

```ts
type T1 = typeof p; // 타입은 Person
type T2 = typeof email; // 타입은 (p: Person, subject: string, body: string) => Response

const v1 = typeof p; // 값은 "object"
const v2 = typeof email; // 값은 "function"
```

타입의 관점에서, `typeof`는 값을 읽어서 타입스크립트 타입을 반환합니다. 타입 공간의 `typeof`는 보다 큰 타입의 일부분으로 사용할 수 있고, `type`구문으로 이름을 붙이는 용도로도 사용할 수 있습니다.   

값의 관점에서 `typeof`는 자바스크립트 런타임의 `typeof` 연산자가 됩니다. 값 공간의 `typeof`는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환하며, 타입스크립트 타입과는 다릅니다. 자바스크립트의 런타임 타입 시스템은 타입스크립트의 정적 타입 시스템보다 훨씬 간단합니다. 타입스크립트 타입의 종류가 무수히 많은 반면, 자바스크립트에는 과거부터 지금까지 단 6개(`string`, `number`, `boolean`, `undefined`, `object`, `function`)의 런타임 타입만이 존재합니다.   

두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 있습니다.
- 값으로 쓰이는 `this`는 자바스크립트의 `this` 키워드입니다. 타입으로 쓰이는 `this`는, 일명 "다형성 `this`"라고 불리는 `this`의 타입스크립트 타입입니다.
- 값에서 `&`와 `|`는 `AND`와 `OR` 비트연산입니다. 타입에서는 인터렉션과 유니온입니다.
- `const`는 새 변수를 선언하지만, `as const`는 리터럴 또는 리터럴 표현식의 추로된 타입을 바꿉니다.
- `extends`는 서브클래스(`class A extends B`) 또는 서브타입(`interface A extends B`) 또는 제너릭 타입 한정자(`Generic<T extends number>`)를 정의할 수 있습니다.
- `in`은 루프 또는 매핑된 타입에 등장합니다.

### 🥕 아이템 9. 타입 단언보다는 타입 선언을 사용하기
타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지입니다.

```ts
interface Person { name: string };

const alice: Person = { name: 'Alice' };
const bob = { name: 'Bob' } as Person;
```

첫 번째 `alice: Person`은 변수에 **타입 선언**을 붙여서 그 값이 선언된 타입임을 명시합니다. 두 번째 `as Person`은 **타입 단언**을 수행합니다. 그러면 타입스크립트가 추론한 타입이 있더라도 `Person` 타입으로 간주합니다.   
타입 단언보다 타입 선언을 사용하는 게 낫습니다. 그 이유는 다음 코드에서 확인할 수 있습니다.

```ts
const alice: Person = {}; // ~~~ 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
const bob = {} as Person; // 오류 없음
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사합니다. 앞의 예제에서는 그러지 못했기 때문에 타입스크립트가 오류를 표시했습니다. 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것입니다.   

타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크도 되는 타입 선언을 사용하는 것이 좋습니다.   

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있습니다. 예를 들어, 다음 코드에서 `Person` 인터페이스를 사용하고 싶다고 가정해 보겠습니다.

```ts
const people = ['alice', 'bob', 'jan'].map(name => ({ name }));
// Person[]을 원했지만 결과는  { name: string; }[]
```

다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적입니다.

```ts
const people = ['alice', 'bob', 'jan'].map(name => {
  const person: Person = { name };
  return person;
}); // 타입은 Person[]
```

코드를 좀 더 간결하게 보이기 위해 변수 대신 화살표 함수의 반환 타입을 선언해 보겠습니다.

```ts
const people = ['alice', 'bob', 'jan'].map((name): Person => ({ name })); // 타입은 Person[]
```

이 코드는 바로 앞의 번잡한 버전과 동일한 체크를 수행합니다. 여기서 소괄호는 매우 중요한 의미를 지닙니다. `name`의 타입이 없고, 반환 타입이 `Person`이라고 명시합니다. 그러나 `(name: Person)`은 `name`의 타입이 `Person`임을 명시하고 반환 타입은 없기 때문에 오류가 발생합니다.   
다음 코드는 최종적으로 원하는 타입을 직접 명시하고, 타입스크립트가 할당문의 유효성을 검사하게 합니다.

```ts
const people: Person[] = ['alice', 'bob', 'jan'].map((name): Person => ({ name })); // 타입은 Person[]
```

그러나 함수 호출 체이닝이 연속된 곳에는 체이닝 시갖에서부터 명명된 타입을 가져야 합니다. 그래야 정확한 곳에 오류가 표시됩니다.   

다음으로 타입 단언이 꼭 필요한 경우를 살펴보겠습니다. 타입 단언은 타입 체커가 추론한 타입보다 여러분이 판단하는 타입이 더 정확할 때 의미가 있습니다. 예를 들어, DOM 엘리먼트에 대해서는 타입스크립트보다 여러분이 더 정확히 알고 있을 겁니다.

```ts
document.querySelector('#myButton').addEventListener('click', (e) => {
  e.currentTarget // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button // 타입은 HTMLButtonElement
});
```

타입스크립트는 DOM에 접근할 수 없기 때문에 `#myButton`이 버튼 엘리먼트인지 알지 못합니다. 그리고 이벤트의 `currentTarget`이 같은 버튼이어야 하는 것도 알지 못합니다. 우리는 타입스크립트가 알지 못하는 정보를 가지고 있기 때문에 여기서는 타입 단언문을 쓰는 것이 타당합니다.

### 🥕 아이템 10. 객체 래퍼 타입 피하기
기본형들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다. 그런데 기본형인 `string`의 경우 메서드를 가지고 있는 것처럼 보입니다. 하지만 사실 `string`의 메서드가 아니며, `string`을 사용할 때 자바스크립트 내부적으로 많은 동작이 일어납니다. `string` 기본형에는 메서드가 없지만, 자바스크립트에는 메서드를 가지는 `String` 객체 타입이 정의되어 있습니다. 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다. `string` 기본형에 `charAt` 같은 메서드를 사용할 때, 자바스크립트는 기본형을 `String` 객체로 래핑하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버립니다.   

만약 `String.prototype`을 몽키-패치한다면 앞서 설명한 내부적인 동작들을 관찰할 수 있습니다.

> 몽키-패치란 런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법을 의미합니다. 자바스크립트에서는 주로 프로토타입을 변경하는 것이 해당됩니다.

메서드 내의 `this`는 `string` 기본형이 아닌 `String` 객체 래퍼입니다. `String` 객체를 직접 생성할 수도 있으며, `string` 기본형처럼 동작합니다. 그러나 `string` 기본형과 `String` 객체 래퍼가 항상 동일하게 동작하는 것은 아닙니다. 예를 들어, `String` 객체는 오직 자기 자신하고만 동일합니다.

```js
"hello" === new String("hello"); // false
new String("hello") === new String("hello"); // false
```

### 🥕 아이템 11. 잉여 속성 체크의 한계 인지하기
타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 '그 외의 속성은 없는지' 확인합니다.

```ts
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present', // 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Room' 형식에 'elephant'가 없습니다.
}
```

`Room` 타입에 생뚱맞게 `elephant` 속성이 있는 것이 어색하긴 하지만, 구조적 타이핑 관점으로 생각해 보면 오류가 발생하지 않아야 합니다. 임시 변수를 도입해 보면 알 수 있는데, `obj` 객체는 `Room` 타입에 할당이 가능합니다.

```ts
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present',
};

const r: Room = obj; // 정상
```

`obj` 타입은 `Room` 타입의 부분 집합을 포함하므로, `Room`에 할당 가능하면 타입 체커도 통과합니다.   

앞 두 예제의 차이점을 살펴보겠습니다. 첫 번째 예제에서는, 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록 **잉여 속성 체크**라는 과정이 수행되었습니다. 그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼라스러워질 수 있습니다. 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입스크립트 타입 시스템에 대한 개념을 정확히 잡을 수 있습니다.   

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적인 방법입니다. 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다릅니다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있습니다.   

잉여 속성 체크에는 한계가 있습니다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 점을 기억해야 합니다.

### 🥕 아이템 12. 함수 표현식에 타입 적용하기
자바스크립트에서는 함수 문장과 함수 표현식을 다르게 인식합니다.

```ts
function rollDice1(sides: number): number { /* ... */ } // 문장
const rollDice2 = function(sides: number): number { /* ... */ }; // 표현식
const rollDice3 = (sides: number): number => { /* ... */ }; // 표현식
```

타입스크립트에서는 함수 표현식을 사용하는 것이 좋습니다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문입니다.

```ts
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { /* ... */ };
```

편집기에서 `sides`에 마우스를 올려 보면, 타입스크릷트에서는 이미 `sides`의 타입을 `number`로 인식하고 있다는 걸 알 수 있습니다. 함수 타입의 선언은 불필요한 코드의 반복을 줄입니다.

```ts
function add(a: number, b: number) { return a + b; }

type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
```

이 예제는 함수 타입 선언을 이용했던 예제보다 타입 구문이 적습니다. 함수 구현부도 분리되어 있어 로직이 보다 분명해집니다. 만약 여러분이 라이브러리를 직접 만들고 있다면, 공통 콜백 함수를 위한 타입 선언을 제공하는 것이 좋습니다.   

함수의 매개변수에 타입 선언을 하는 것보다 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전합니다. 다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 매개변수의 타입과 반환 타입을 반복해서 작성하지 말고 함수 전체의 타입 선언을 적용해야 합니다.
