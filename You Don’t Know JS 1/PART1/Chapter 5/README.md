# 🌈 Chapter 5 : 문법

<details>
<summary>Table of Contents</summary>

- 문과 표현식 [:link:](#-문과-표현식)
  - 문의 완료 값 [:link:](#-문의-완료-값)
  - 표현식의 부수 효과 [:link:](#-표현식의-부수-효과)


</details>

## 🎯 문과 표현식
- 자바스크립트 문법에서 문(Statement)은 문장(Sentence), 표현식(Expression)은 어구(Phrase), 연산자는 구두점/접속사에 해당된다.
- 자바스크립트에서 모든 **표현식은 단일한, 특정한 결괏값으로 계산된다.**

```javascript
var a = 3 * 6;
var b = a;
b;
```
- 여기서 `3 * 6`은 표현식이다. 두 번째 줄 역시 표현식이며, 세 번째 줄 b도 표현식이다.
- 이 세 줄은 각각 표현식이 포함된 문이다.
- 첫 번째, 두 번째 두 문은 각각 **변수를 선언하므로 선언문(Declaration Statement)이라 한다.**
- 앞에 `var`이 빠진 `a = 3 * 6`, `b = a`는 **할당 표현식(Assignment Expression)이라고 한다.**
- 세 번째 줄은 b가 표현식의 전부이지만 이것만으로도 완전한 문이다. 일반적으로 이런 문을 **표현식 문(Expression Statement)이라고 일컫는다.**

### 📚 문의 완료 값
- 모든 문은 (그 값이 undefined라 해도) 완료 값을 가진다.
> - ES5.1. 문 도입부에 문의 평가 결과는 항상 완료 값이다.
> - 또한, 크롬의 콘솔 창에서 최근에 실행된 문의 완료 값을 기본적으로 출력하게 되어 있는점.
- `var b = a` 같은 문의 완료 값은?? 할당 표현식 `b = a`는 할당 이후의 값이 완료 값이지만, `var`문 자체의 완료 값은 `undefined`다. ([명세](http://www.ecma-international.org/ecma-262/5.1/#sec-12.2)에 적혀있음.)
- 그러나 콘솔 창이 내어준 완료 값은 개발자가 내부 프로그램에서 사용할 수 있는 값은 아니다. 완료 값을 순간 포착할 방법은??
- 그 전에 다른 종류의 문 완료 값을 보자.
- 예를 들어, 보통의 `{}` 블록은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료 값으로 반환한다.

```javascript
var b;

if (true) {
  b = 4 + 38;
}
```
- 콘솔 창에서 실행하면 42가 나오는데 블록 내의 마지막 문 `b = 4 + 38`의 완료 값이 42 이므로 `if` 블록의 완료 값도 42를 반환한 것이다.
- 즉, 블록의 완료 값은 **내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.**
- 하지만 다음과 같은 코드가 작동하지 않는 건 분명히 문제가 있다.

```javascript
var a, b;
a = if(true) {
  b = 4 + 38;
}
// Uncaught SyntaxError: Unexpected token 'if'
```
- **문의 완료 값을 포착하여 다른 변수에 할당하는 건 쉬운 구문/문법으로는 불가능하다.**
- 완료 값을 포착하려면 어쩔 수 없이 유해함의 대명사 `eval()` 함수를 사용할 수밖에 없다.

```javascript
var a, b;
a = eval('if (true) { b = 4 + 38; }');
a; // 42
```
- ES7 명세에는 `do`표현식이 제안된 상태이다.

```javascript
var a, b;
a = do{
  if(true){
    b = 4 + 38;
  }
};
a; // 42가 나와야 하지만 나오지 않음 에러뜸..
```

- `do{ }` 표현식은 블록 실행 후 블록 내 마지막 문의 완료 값을 `do` 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.
- `eval()`은 절대 사용하지 말자.

### 📚 표현식의 부수 효과
- 대부분의 표현식에는 부수 효과가 없다.

```javascript
var a = 2;
var b = a + 3;
```

- 표현식 `a + 3` 자체는 가령 a 값을 바꾸는 등의 부수 효과가 전혀 없다.
- 단지 `b = a + 3` 문에서 결괏값 5가 b에 할당될 뿐이다.
- 다음 함수 호출 표현식은 부수 효과를 가진 표현석의 전형적인 예다.

```javascript
function foo() {
  a = a + 1;
}

var a = 1;
foo(); // undefined.  a는 2로 변경
```
- 다른 부수 효과를 지닌 표현식.

```javascript
var a = 42;
var b = a++;

a; // 43
b; // 42
```

- `a++`이 하는 일은 두 가지다.
- a의 현재 값 42를 반환하고 a값을 1만큼 증가시킨다.
- `a++`를 ()로 감싸면 후위 부수 효과를 캡슐화할 수 있다고 착각할 수 있지만 `a++` 표현식에서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다.

```javascript
var a = 42;
var b = (a++);

a; // 43
b; // 42
```

- 문을 나열하는(Statement-Series) 콤마 연산자`,`를 사용하면 다수의 개발 표현식을 하나의 문으로 연결할 수 있다.

```javascript
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```
- `a++`, `a` 표현식은 두 번째 a 표현식을 첫 번째 `a++` 표현식에서 부수 효과가 발생한 이후에 평가한다. 그래서 b의 앖은 43이다.
- `delete` 역시 부수 효과를 일으키는 연산자이다.

```javascript
var obj = {
  a: 42
};

obj.a; // 42
delete obj.a; // true
obj.a; // undefined
```

- 이 연산자의 부수 효과는 바로 프로퍼티를 제거하는 것이다.

```javascript
var a;

a = 42; // 42
a; // 42
```
- `a = 42`에서 `=` 연산자는 부수 효과와 무관해 보이지만 `a = 42` 문의 **실행 결과는 이제 막 할당된 값**이므로 42를 a에 할당하는 자체가 본질적으로 부수 효과이다.
- 이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 다음과 같은 **연쇄 할당문(Chained Assignment)** 에서 특히 유용하다.

```javascript
var a, b, c;
a = b = c = 42;
```
- 위 예와 같은 경우 42를 c에 할당하는 부수 효과를 일으키며, 42를 b에 할당하는 부수 효과를 일으키고, 42를 a에 할당하는 부수 효과를 일으킨다.

```javascript
function vowels(str) {
  var matches;

  if(str){
    // 모든 모음을 추출한다.
    matches = str.match(/[aeiou]/g);

    if(matches){
      return matches;
    }
  }
}

vowels('Hello World'); // ['e', 'o', 'o']
```
- 할당 연산자의 부수 효과를 잘 활용하면 다음과 같이 2개의 `if`문을 하나로 간단히 합칠 수 있다.

```javascript
function vowels(str) {
  var matches;

  // 모든 모음을 추출한다.
  if(str && (matches = str.match(/[aeiou]/g))){
    return matches;
  }
}

vowels('Hello World'); // ['e', 'o', 'o']
```

### 📚 콘텍스트 규칙

#### 📌 중괄호
- 자바스크립트에서 중괄화 `{}`가 나올 법한 곳은 크게 두 군데이다.
1. **객체 리터럴**

```javascript
var a = {
  foo: bar()
};
```
- `{}`는 a에 할당될 값이므로 객체 리터럴이다.

2. **레이블**

```javascript
{
  foo: bar()
}
```
- `{}`는 어디에도 할당되지 않은, 고립된 객체 리터럴처럼 보이지만 그렇지 않다.
- 여기서의 `{}`는 평범한 코드 블록이다.
- `let` 블록 스코프 선언과 함께 쓰이면 아주 유용하다.
- `{}` 코드 블록은 `for/while` 루프, `if` 조건 등에 붙어있는 코드 블록과 기능적으로 매우 유사하다.
- 이것은 자바스크립트에서 **레이블 문(Labeled statement)** 이라 부르는, 거의 잘 알려지지 않은(권장 하지 않는다.) 기능 덕분이다.
- 즉, `foo`는 `bar()`문의 레이블이다.
- 자바스크립트에는 레이블 점프(Labeled Jump)라는 특별한 형태의 `goto`장치가 대신 마련되어 있다.
- `continue`와 `break` 문은 선택적으로 어떤 레이블을 받아 `goto`처럼 프로그램의 실행 흐름을 점프시킨다.

```javascript
foo: for(var i = 0; i < 4; i++) {
  for(var j = 0; j < 4; j++) {
    if(j == i) {
      // 다음 순회 시 foo 붙은 루프로 점프한다.
      continue foo;
    }

    if((j * i) % 2 == 1) {
      // 평범한, 안쪽 루프의 continue
      continue;
    }
    console.log(i, j);
  }
}

// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

- `continue foo`는 `foo`라는 레이블 위치로 이동하여 계속 순회하라는 의미가 아니라 `foo`라는 **레이블이 붙은 루프의 다음 순회를 계속하라라는 뜻**이다. 따라서 사실 임의적인 `goto`와는 다르다.
- `break foo`는 `foo`라는 레이블 위치로 이동하여 계속 순회하라는 의미가 아니라, `foo`라는 **레이블이 붙은 바깥쪽 루프/블록 밖으로 나가 그 이후부터 계속하라는 뜻**이다.
- 레이블은 비 루프(Nonloop)블록에 적용할 수 있는다, 단 이런 비 루프 레이블은 `break`만 참조할 수 있다.
- 레이블 `break __`를 써서 레이블 블록 밖으로 나갈 수는 있지만, 비 루프 블록을 `continue __` 한다든가, 레이블이 없는 `break`로 블록을 빠져나가는 건 안 된다.

```javascript
function foo() {
  bar: {
    console.log('hello');
    break bar;
    console.log('실행 안 된다.');
  }
  console.log('world');
}
foo();
// hello
// world
```
- 레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석도 많아 가능한 피하는게 좋다.
- 이를테면 루프 점프를 할 바에야 차라리 함수 호출이 더 낫다.

3. **블록**

```javascript
[] + {}; // "[object Object]"
{} + []; // 0
```
- 윗 줄에서 엔진은 `+` 연산자 표현식의 `{}`를 실제 값(빈 객체)으로 해석한다.
- **`[]`는  `""`로 강제변환되고 `{}`도 문자열 `"[object Object]"`로 강제변환된다.**
- 그러나 **아랫 줄의 `{}`는 동떨어진 빈 블록으로 간주한다.**
- 블록 끝을 꼭 세미콜론으로 끝나야 한다는 법은 없으므로 문제 될 건 없다.
- **결국  `+ []`표현식에서 명시적으로 `[]`를 숫자 0으로 강제변환한다.**

4. **객체 분해**
- ES6부터 분해 할당(Destructuring Assignments), 구체적으로는 객체 분해시 `{}`를 사용한다.

```javascript
function getData() {
  // ...
  return {
    a: 42,
    b: 'foo',
  };
}

var { a, b } = getData();
console.log(a, b); // 42 'foo'
```

- `{}`를 이용한 객체 분해는 명명된 함수에도 활용할 수 있는데, 이를테면 암시적인 객체 프로퍼티 할당과 비슷한 간편 구문이다.

```javascript
function foo({a, b, c}) {
  // 다음 코드처럼 할 필요가 없다.
  // var a = obj.a, b = obj.b, c = obj.c
  console.log(a, b, c);
}

foo({
  c: [1, 2, 3],
  a: 42,
  b: 'foo',
});
// 42 "foo" [1, 2, 3]
```

5. **else if와 선택적 블록**

```javascript
if (a) {
  // ...
}
else if (b) {
 // ...
}
else {
  // ...
}
```
- 실은 `else if` 같은 건 없다. 자바스크립트 문법의 숨겨진 특성이다.
- `if`와 `else`문의 실행문이 하나밖에 없는 경우 블록을 감싸는 `{}`를 생략해도 된다.

```javascript
if (a) doSomething(a);
```
- 여러 스타일 가이드 문서에는 단일 문 블록도 `{}`로 감싸라고 조언한다.

```javascript
if (a) { doSomething(a); }
```
- 그러나 정확히 동일한 문법 규칙이 `else` 절에도 적용되어 좀 전에 봤던 코드는 실제로는 항상 이렇게 파싱된다.

```javascript
if (a) {
 // ...
}
else {
  if (b) {
    // ...
  }
  else {
    // ...
  }
}
```
- 즉, `else if`라고 쓰는 건 표준 스타일 가이드의 위반 사례가 되며, 단일 `if` 문과 같이 `else`를 정의한 셈이 된다.
- 물론 `else if`는 이미 누구나 다 쓰는 관용 코드고, 한 단계  하위로 들여 쓰기를 하는 효과가 있어 나름 매력은 있다.