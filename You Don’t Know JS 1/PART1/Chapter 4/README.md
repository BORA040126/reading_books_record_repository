## 🌈 Chapter 4 : 강제변환


### 🎯 값 변환

- 어떤 값을 다른 타입의 값으로 바꾸는 과정이 **명시적이면 타입 캐스팅(Type Casting)**, **암시적이면 강제변환(Coercion)** 이라고 한다.
- 항상 그렇지 안을 수도 있지만 자바스크립트에서 강제변환을 하면 문자열, 숫자, 불리언 같은 스칼라 원시 값 중 하나가 되며, 객체, 함수 같은 합성 값 타입으로 변환될 일은 없다.
- 이렇게도 구분할 수 있는데, 타입 캐스팅(타입 변환)은 **정적 타입 언어에서 컴파일 시점**에, 강제변환은 **동적 타입 언어에서 런타임 시점**에 발생한다.
- 그러나 자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컽는 경향이 있어서, 암시적 강제변환과 명시적 강제변환 두 가지로 구별할 수도 있다.
- 명시적 강제변환은 **의도적으로 타입변환을 일으킨다는 사실이 명백**한 반면, 암시적 강제변환은 **다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환**이다.

```javascript
var a = 42;
var b = a + ''; // 암시적 강제변환
var c = String(a); // 명시적 강제변환
```

- 둘의 차이는 엄밀히 말해 스타일의 차이뿐 아니라 작동상에도 미묘한 차이가 있다.
- 명시적(Explicit) : 암시적(Implicit) = 명백한(Obvious) : 숨겨진 부수 효과(Hidden Side Effect) 용어상으로는 이러한 대응 관계가 성립


### 🎯 추상 연산

#### 📚 ToString
- 문자열이 아닌 값 -> 문자열 변환 작업은 ES5 9.8의 `ToString` 추상 연산 로직이 담당한다.

```javascript
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

a; // 1.07e+21
a.toString(); // "1.07e+21"
```
- 일반 객체는 특별히 지정하지 않으면 기본적으로 `toString()` 메서드가 내부 `[[Class]]`를 반환한다.
- 자신의 `toString()` 메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 기본 호출되어 `toString()`을 대체한다.
- 배열은 기본적으로 재정의된 `toString()`이 있다. 문자열 변환 시 모든 원소 값이 콤마(.)로 분리된 형태로 이어진다.

```javascript
var a = [1, 2, 3];
a.toString(); // "1,2,3"
```
- 또한 `toString()` 메서드는 **명시적으로도 호출 가능**하며, 문자열 콘텍스트에서 **문자열 아닌 값이 있을 경우에도 자동 호출된다.**

**📌 JSON 문자열화**
- `ToString`은 `JSON.stringify()` 유틸리티를 사용하여 어떤 값을 `JSON` 문자열로 직렬화하는 문제와도 연관된다.
- `JSON` 문자열화는 강제변환과 똑같지는 않지만, `ToString` 규칙과 관련이 있다.
- 대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는, `JSON`문자열화나 `toString()` 변환이나 기본적으로 같은 로직이다.

```javascript
JSON.stringify(42); // "42"
JSON.stringify("42"); // ""42""
JSON.stringify(null); // "null"
JSON.stringify(true); // "true"
```

- `JSON` 안전 값(`JSON` 표현형으로 확실히 나타낼 수 있는 값)은 모두 `JSON.stringify()`로 문자열화할 수 있다.
- `JSON` 안전 값이 아닌 것들은 `undefined`, 함수, 심벌, 환형 참조 객체(프로퍼티 참조가 무한 순환되는 구조의 객체) 같은 것들이다.
- 만약 `JSON.stringify()`는 안전 값이 아닌 것들은 자동으로 누락시키며 만약 배열에 포함되어 있으면 `null`로 바꾼다. 객체 프로퍼티에 있으면 지워버린다.

```javascript
JSON.stringify(undefined); // undefined
JSON.stringify(function(){}); // undefined

JSON.stringify([1, undefined, function(){}, 4]); // "[1,null,null,4]"
JSON.stringify({ a:2, b: function(){} }) // "{"a":2}"
```

- 환형 참조 객체를 넘기면 에러가 발생한다.
- 객체 자체에 `toJSON()` 메서드가 정의되어 있다면 먼저 이 메서드를 호출하여 직렬화한 값을 반환한다.
- 부적절한 `JSON`값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 `toJSON()` 메서드를 따로 정의해야 한다.

```javascript
var o = {};
var a = {
  b: 42,
  c: o,
  d: function(){}
};

// a를 환형 참조 객체로 만든다.
o.e = a;

// 에러 발생
JSON.stringify(a); // Uncaught TypeError: Converting circular structure to JSON

// JSON 값으로 직렬화하는 함수를 따로 정의한다.
a.toJSON = function() {
  return { b: this.b }; // 직렬화에 b만 포함시킨다.
}

JSON.stringify(a); // "{"b":42}"
```

- `toJSON()`은 적절히 평범한 실제 값을 반환하고 문자열화 처리는 `JSON.stringify()`이 담당한다.
- 다시말해 `toJSON()`의 역할은 **문자열화하기 적당한 `JSON` 안전 값을 바꾸는 것**이지, `JSON` 문자열로 바꾸는 것이 아니다.

```javascript
var a = {
  val: [1, 2, 3],
  // 맞다
  toJSON: function() {
    return this.val.slice(1);
  }
};

var b = {
  val: [1, 2, 3],
  // 틀리다
  toJSON: function() {
    return '[' + this.val.slice(1).join() + ']';
  }
};

JSON.stringify(a); // "[2,3]"
JSON.stringify(b); // ""[2,3]""
```

- 배열 아니면 함수 형태의 대체자를 `JSON.stringify()`의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 필터링 하는 방법이 있다. `toJSON()`이 직렬화할 값을 준비하는 방식과 비슷하다.
- 대체자가 배열이면 **전체 원소는 문자열이어야 하고 각 원소는 객체 직렬화의 대상 프로퍼티명이다.** 즉, 여기에 포함되지 않은 프로퍼티는 직렬화 과정에서 빠진다.
- 대체자가 함수면 처음 한 번은 객체 자신에 대해, 그 다음엔 각 객체 프로퍼티별로 한 번씩 실행하면서 매번 키와 값 두 인자를 전달한다. 직렬화 과정에서 해당 키를 건너뛰려면 `undefined`를 그 외엔 해당 값을 반환한다.

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
};
JSON.stringify(a, ['b', 'c']); // "{"b":42,"c":"42"}"
JSON.stringify(a, function(k, v) {
  if(k !== 'c') return v;
}); // "{"b":42,"d":[1,2,3]}"
```

- 함수인 대체자는 최초 호출 시 키 인자 `k`는 `undefined`이다.
- 대체자는 `if` 문에서 키가 `c`인 프로퍼티를 솎아내고 문자열화는 재귀적으로 이루어지므로 배열 `[1,2,3]`의 각 원소는 `v`(1,2,3)로, 인덱스는 `k`(0,1,2)로 각각 대체자 함수에 전달된다.
- `JSON.stringify()`의 세 번째 선택 인자는 스페이스라고 하며 사람이 읽기 쉽도록 들여쓰기를 할 수 있다.
- 들여 쓰기를 할 빈 공간의 개수를 숫자로 지정하거나 문자열(10자 이상이면 앞에서 10자까지만 잘라 사용한다)을 지정하여 각 들여 쓰기 수준에 사용한다.

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3]
};

JSON.stringify(a, null, 3);
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       null,
//       3
//    ]
// }"
JSON.stringify(a, null, '-----');
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------null,
// ----------3
// -----]
// }"
```

- `JSON.stringify()`는 직접적인 강제변환의 형식은 아니지만 두 가지 이유로 `ToString` 강제변환과 연관된다.
  - 문자열, 숫자, 불리언, `null` 값이 `JSON`으로 문자열화하는 방식은 `ToString` 추상 연산의 규칙에 따라 문자열 값으로 강제변환되는 방식과 동일하다.
  - `JSON.stringify()`에 전달한 객체가 **자체 `toJSON()` 메서드를 갖고 있다면**, **문자열화 전 `toJSON()`이 자동 호출**되어 **`JSON` 안전 값으로 강제변환**된다.