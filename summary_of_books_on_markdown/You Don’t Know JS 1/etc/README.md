## ✌ 함수

### 📚 함수 선언문이란?
```js
// 함수 선언문
function square(number) {
  return number * number;
}
```

### 📚 함수 표현식이란?
- 일급 객체의 특성을 이용한 함수 리터럴 방식
- 함수를 정의하고 변수에 할당할 수 있다.
- 함수명을 생략하면 익명 함수
- 함수 호출시 함수명이 아니라 함수를 가리키는 변수명을 사용 (함수 표현식에서 함수명은 외부 코드에서 접근 불가)


### 📚 Function 생성자 함수
- 함수 표현식과 함수 선언문은 내장 함수 `Function` 생성자 함수로 함수를 생성하는 것을 단순화시킨 축약법

### 📚 함수 호이스팅
- 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능하다.
- 자바스크립트는 ES6의 `let`, `const`를 포함하여 모든 선언을 호이스팅한다.
- 호이스팅이란 모든 선언문이 해당 scope의 선두로 옮겨진 것처럼 동작하는 특성, 때문에 선언되기 이전에 참조 가능
- 함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO에 저장한다. 즉, 함수 선언, 초기화, 할당이 한번에 이루어진다.
- 함수 표현식의 경우 함수 호이스팅이 아니라 [변수 호이스팅](https://poiemaweb.com/js-data-type-variable#24-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)이 발생한다.

> 변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다.
- 함수 선언문으로 함수를 정의하면 사용하기에 쉽지만 대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다.

### 📚 First-class object (일급 객체)
- 자바스크립트의 함수는 일급 객체이다.
- 무명의 리터럴로 표현이 가능하다.
- 변수나 자료구조에 저장 가능
- 함수의 파라미터로 전달 가능
- 반환값으로 사용할 수 있다.

### 📚 매개변수(parameter, 인자) vs 인수(argument)
- 매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당된다. 인수를 전달받지 않으면 매개변수는 `undefined`

### 📚 Call-by-value
- 원시 타입 인수는 Call-by-value(값에 의한 호출)로 동작한다.
- 매개변수에 값을 복사하여 함수로 전달한다. 때문에 원시타입 값은 변경되지 않는다.

### 📚 Call-by-reference
- 객체형(참조형) 인수는 Call-by-reference(참조에 의한 호출)로 동작.
- 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식이다. 때문에 참조형의 인수값도 같이 변경된다.
- 때문에 원본 객체가 변경되는 부수 효과(side-effect)가 발생한다. 부수 효과를 발생시키면 비순수 함수라고 한다.

### 📚 함수 객체의 프로퍼티
- 함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다.

```js
function square(number) {
  return number * number;
}

square.x = 10;
square.y = 20;

console.log(square.x, square.y);
```

### 📚 arguments 프로퍼티
- `arguments` 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 iterable한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다. 즉, 외부에서 사용할 수 없다.
- 유사배열객체란 length 프로퍼티를 가진 객체를 말한다.

### 📚 즉시 실행 함수
- 함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수라고 한다. 최초 한번만 호출되며 다시 호출할 수 없다.
- 함수 선언문은  자바스크립트엔진에 의해 중괄호가 붙기 때문에 소괄호로 감싸준다.
- JQuery / 충돌방지 가능

### 📚 재귀 함수
- 재귀 함수(Recusive function)는 자기 자신을 호출하는 함수를 말한다.
- 하지만 스택 오버 플로우가 발생할 수 있다. 이 단점을 보완하기 위해서 꼬리 재귀 최적화 방법이 존재.
- 꼬리 재귀란, 재귀 호출이 끝난 후 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 재귀의 형태 But 최적화를 지원하는지 확인해야함.


## ✌ 스코프

### 📚 스코프란?
- 어떤 대상을 다른 대상와 구분하여 식별할 수 있는 유일한 이름을 찾아내기 위한 규칙이다.
- 이 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한 범위를 찾는다.

```js
var x = 'global';

function foo () {
  var x = 'function scope';
  console.log(x);
}

foo(); // function scope
console.log(x); // global
```
- 전역에 선언된 변수 x는 어디에든 참조가능 하지만 함수 `foo` 내에서 선언된 변수 x는 함수 `foo` 내부에서만 참조할 수 있고 함수 외부에서는 참조 불가. 이러한 규칙을 스코프라고 한다.

### 📚 스코프의 구분
- 전역 스코프
- 지역 스코프
- 변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다.
- 전역 스코프를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

### 📚 자바스크립트 스코프의 특징
- 자바스크립트는 함수 레벨 스코프를 따른다. 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다.
- 단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있다.

### 📚 렉시컬 스코프

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

- 함수를 어디서 호출하였는지에 따라 상위스코프를 결정하는 것과 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다.
- 첫번째 방법이면 `bar` 상위 스코프는 `foo()`와 전역이고 두 번째 방법이면 `bar`는 전역 스코프일 것이다.
- 첫번째 방법은 동적 스코프라고 하고 두번째 방식을 렉시컬 스코프 또는 정적 스코프라고 한다.
- 자바스크립트는 렉시컬 스코프를 따른다.
- 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.

### 📚 [암묵적 전역](https://poiemaweb.com/js-scope#8-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%A0%84%EC%97%AD)

## ✌ 함수 호출 방식에 의해 결정되는 this
- 자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에 `arguments` 객체와 `this`를 암묵적으로 전달받는다.
- 자바스크립트는 Java와 달리 `this`에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 `this`에 바인딩되는 객체가 달라진다.
- 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 `this`에 바인딩할 객체가 동적으로 결정된다.
- 함수를 호출하는 방식
  - 함수 호출
  - 메소드 호출
  - 생성자 함수 호출
  - apply/call/bind 호출

```js
var foo = function () {
  console.dir(this);
};

// 1. 함수 호출
foo(); // window
// window.foo();

// 2. 메소드 호출
var obj = { foo: foo };
obj.foo(); // obj

// 3. 생성자 함수 호출
var instance = new foo(); // instance

// 4. apply/call/bind 호출
var bar = { name: 'bar' };
foo.call(bar);   // bar
foo.apply(bar);  // bar
foo.bind(bar)(); // bar
```

### 📚 [함수 호출](https://poiemaweb.com/js-this#1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C)
- 전역 객체는 모든 객체의 유일한 최상위 객체를 의미하며 브라우저에서는 window, node.js에서는 global객체를 의미한다.
- 기본적으로 this는 전역객체에 바인딩된다. 전역함수는 물론이고 내부함수의 경우에도 this는 외부함수가 아닌 전역 객체에 바인딩된다. 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩된다.
- 콜백함수의 경우에도 `this`는 전역객체에 바인딩된다.
- **내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다.** 

### 📚 메소드 호출
- 함수가 객체의 프로퍼티 값이면 메소드로서 호출된다.
- 이때 메소드 내부의 `this`는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.

```js
var obj1 = {
  name: 'Lee',
  sayName: function() {
    console.log(this.name);
  }
}

var obj2 = {
  name: 'Kim'
}

obj2.sayName = obj1.sayName;

obj1.sayName(); // Lee
obj2.sayName(); // Kim
```

### 📚 [생성자 함수 호출](https://poiemaweb.com/js-this#3-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C)
- 기존 함수에 `new` 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
1. 빈 객체 생성 및 this 바인딩 => 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다.

2. this를 통한 프로퍼티 생성 => 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성할 수 있다.

3. 생성된 객체 반환

## ✌ [실행 컨텍스트](https://poiemaweb.com/js-execution-context)

### 📚 실행 컨텍스트의 3가지 객체
#### Variable Object (VO / 변수객체)
- 실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성한다. 이를 Variable Object(VO / 변수 객체)라고 한다.
- Variable Object는 코드가 실행될 때 엔진에 의해 참조되며 코드에서는 접근할 수 없다.
- 변수, 매개변수(parameter)와 인수 정보(arguments) ,함수 선언(함수 표현식은 제외)
- Variable Object가 가리키는 객체가 전역 컨텍스트의 경우는 전역객체를 가리킨다.
- 함수 컨텍스트의 경우는 AO(활성 객체)를 가리키며 매개변수와 안수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.

#### Scope Chain (SC)
- 스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다.

## ✌ [클로저](https://poiemaweb.com/js-closure)
- 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다.
- 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수
- 상태 유지 (현재 상태를 기억하고 변견된 최신 상태를 유지)
- 전역 변수의 사용을 억제
- 정보의 은닉

### 📚 고차 함수
- 고차 함수(Higher order function)는 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수를 말한다. 
- 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다. 자바스크립트의 함수는 일급 객체이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다.
- 고차 함수는 외부 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에 기반을 두고 있다. 
- 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다.

### 📚 REST(Representational State Transfer) API
- URI는 정보의 자원을 표현해야 한다.
  - 리소스명은 동사보다는 명사를 사용한다. URI는 자원을 표현하는데 중점을 두어야 한다. get 같은 행위에 대한 표현이 들어가서는 안된다.
- 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현한다.

## ✌ [let, const와 블록 레벨 스코프](https://poiemaweb.com/es6-block-scope)
- 블록 레벨 스코프
- let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 

## ✌ [화살표 함수](https://poiemaweb.com/es6-arrow-function)

### 📚 일반 함수의 this
- 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다.

### 📚 화살표 함수의 this
- 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.
- 동적으로 결정되는 일반 함수와는 달리 화살표 함수의 `this` 언제나 상위 스코프의 `this`를 가리킨다. (`Lexical this`)


## ✌ [커링](https://ko.javascript.info/currying-partials)
