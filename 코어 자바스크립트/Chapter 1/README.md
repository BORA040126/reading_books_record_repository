# 🌈 Chapter 1: 데이터 타입

## 📚 데이터 타입의 종류
- 기본형(원시형)
  - 숫자, 문자열, 불리언, `null`, `undefined`, `Symbol`(ES6)
- 참조형
  - 객체, 배열, 함수, 날짜, 정규표현식
  - ES6: Map, WeakMap, Set, WeakSet
- 기본형과 참조형을 구분하는 기준은 기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

## 📚 데이터 타입에 관한 배경지식
  
### 🎈 메모리와 데이터
- 각 비트는 고유한 식별자를 지닌다. 바이트 역시 시작하는 비트의 식별자로 위치를 파악한다.
- 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있다.

### 🎈 식별자와 변수
- 변수는 변할 수 있는 수로 값이 반드시 숫자여야 하는 것은 아니다. 즉, **변할 수 있는 무언가**라는 뜻으로 여기서 무언가란 **데이터**를 말한다. 숫자, 문자열, 객체, 배열 등등.
- 식별자는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**이다.

## 📚 변수 선언과 데이터 할당

### 🎈 변수 선언

```js
var a;
```

- 위 예는 *변할 수 있는 데이터를 만든다. 이 데이터는 식별자는 `a`로 한다.*라고 말할 수 있다.
- 변수란 결국 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 할 수 있다.
- 예제의 명령을 받은 컴퓨터는 메모리에서 비어있는 공간 하나를 확보한다. 그 공간을 임의로 1003번으로 정했다. 이 공간의 이름(식별자)을 `a`라고 지정한다. (변수 선언 과정)
- 이후 사용자가 `a`에 접근하고자 하면 컴퓨터는 메모리에서 `a`라는 이믈을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환한다.

### 🎈 데이터 할당
- 변수 선언과 할당

```js
var a; // 변수a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 선언과 할당을 한 문자으로 표현
```

- 자바스크립트에서 할당은 실제로는 해당 위치에 문자열 `abc`를 직접 저장하지 않는다.
- 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 `abc`를 저장하고, 그 주소를 변수 영역에 저장하는 식으로 이뤄진다.

> 1. 변수 영역에서 빈 공간(1003)을 확보한다.
> 2. 확보한 공간의 식별자를 a로 지정한다.
> 3. 데이터 영역의 빈 공간(5004)에 문자열 abc를 저장한다.
> 4. 변수 영역에서 a라는 식별자를 검색한다.(1003)
> 5. 앞서 저장한 문자열의 주소(5004)를 1003의 공간에 대입한다.

#### 🐶 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 거치는 이유
- 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과이다.
- 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해서는 확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업이 선행되어야 한다.
- 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.
- 문자열 `abc`의 마지막에 `def`를 추가하라고 하면 컴퓨터는 앞서 `abc`가 저장된 공간에 `abcdef`를 할당하는 대신 `abcdef`라는 문자열을 **새로** 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결한다. 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장한다.
- 기존 데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터(GC)의 수거 대상이 된다.
- 또한, 예를 들어 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황이라면 이 경우는 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력해준다. 그렇기 때문에 중복된 데이터에 대한 처리 효율이 높아지게 되는 것이다.

## 📚 기본형 데이터와 참조형 데이터

### 🎈 불변값
- 변수와 상수를 구분하는 성질은 변경 가능성이다.
- 변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 즉, 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이 된다.
- 반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.
- 기본형 데이터는 모두 불변값이다.

```js
var a = 'abc';
a = a + 'def';

var b = 5;
var c = 5;
b = 7;
```

- 변수 a에 문자열 `abc`를 할당했다가 `def`를 추가하면 기존의 `abc`가 `abcdef`로 바뀌는 것이 아니라 새로운 문자열 `abcdef`를 만들어 그 주소를 변수 `a`에 저장한다. 즉, `abc`와 `abcdef`는 완전히 별개의 데이터이다.
- 변수 b에 숫자 5를 할당하는데 컴퓨터는 데이터 영역에서 5를 찾고 없으니 데이터 공간을 하나 만들어 저장한 뒤 그 주소를 b에 저장한다. 변수 c는 변수 b와 같은 수인 5를 할당하려고 한다. 컴퓨터는 데이터 영역에서 5를 찾고 이미 5가 존재하니 그 주소를 재활용한다.
- 변수 b를 7로 바꾸고자 한다. 그러면 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어 b에 저장한다. 
- 결국 5와 7 모두 다른 값으로 변경할 수 없다.
- 이처럼 문자열 값도 한 번 만든 값을 바꿀 수 없고, 숫자 값도 다른 값으로 변경할 수 없다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

### 🎈 가변값
- 참조형 데이터의 할당

```js
var obj1 = {
  a: 1,
  b: 'bbb',
};
```

- 다음은 참조형 데이터를 변수에 할당하는 과정이다.

> 1. 컴퓨터는 우선 변수 영역의 빈 공간(1002)을 확보하고, 그 주소의 이름을 `obj1`로 지정한다.
> 2. 임의의 데이터 저장 공간(5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고 그 영역의 주소(7103 ~ ?)를 5001에 저장한다.
> 3. 7103 및 7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.
> 4. 데이터 영역에서 숫자 1을 검색하고 검색 결과가 없으므로 임의로 5003에 저장하고, 이 주소를 7103에 저장한다. 문자열 `bbb`역시 5004에 저장하고 이 주소를 7104에 저장한다.

- 기본형 데이터와의 차이는 객체의 변수 영역이 별도로 존재한다는 점이다. 객체가 별도로 할애한 영역은 변수 영역일 뿐 데이터 영역은 기존의 메모리 공간을 그대로 활용하고 있다. 데이터 영역은 불변값이지만 변수에는 다른 값이 얼마든지 대입할 수 있다. 그렇기 떄문에 참조형 데이터는 불변 하지 않다라는 것이다.

```js
// 참조형 데이터의 프로퍼티 재할당
var obj1 = {
  a: 1,
  b: 'bbb',
};
obj1.a = 2;
```

- `obj1`의 `a` 프로퍼티에 숫자 2를 할당하려고 한다. 데이터 영역에서 숫자 2를 검색한다. 검색 결과가 없으므로 빈 공간인 5005에 저장하고 이 주소를 7103에 저장한다. 그렇기 때문에 변수 `obj1`이 바라보고 있는 주소는 5001로 그대로이다. 즉, 새로운 객체가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.

### 🎈 변수 복사 비교
- 기본형 데이터와 참조형 데이터의 차이
- 변수 복사

```js
var a = 10;
var b = a;

var obj1 = {
  c: 10,
  d: 'ddd',
};
var obj2 = obj1;
```

- 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.
- 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다.

```js
var a = 10;
var b = a;

var obj1 = {
  c: 10,
  d: 'ddd',
};
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

- 기본형 데이터를 복사한 후 변수 `b`의 값을 바꿨더니 값이 달라지는 반면, 참조형 데이터를 복사한 변수 `obj2`의 프로퍼티의 값을 바꾸었더니 값은 달라지지 않았다.
- 즉, 변수 `a`와 `b`는 서로 다른 주소를 바라보게 됐으나, 변수 `obj1`과 `obj2`는 여전히 같은 객체를 바라보고 있는 상태이다. 이를 코드로 표현하면 다음과 같다.

```js
a !== b;
obj === obj2;
```
- 자바스크립트는 사실 어떤 데이터 타입ㅇ이든 별수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에, 엄밀히 따지면 모든 데이터 타입은 참조형 데이터일 수밖에 없다.
- 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있다는 것이다.

```js
// 객체 자체를 변경했을 때
var a = 10;
var b = a;

var obj1 = {
  c: 10,
  d: 'ddd',
};
var obj2 = obj1;

b = 15;
obj2 = {
  c: 20,
  d: 'ddd'
};
```

- 이번에는 새로운 객체를 할당함으로써 값을 직접 변경했다. 그러면 메모리의 데이터 영역에 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 `obj2` 위치에 저장할 것이다.
- 즉, 참조형 데이터가 *가변값*이라고 설명할 때의 *가변*은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.